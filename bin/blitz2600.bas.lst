------- FILE c:\Users\danie\Documents\GitHub\atari-blitz2600\blitz2600.bas.asm LEVEL 1 PASS 3
      1  8400 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8400 ????
      3  8400 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  8400 ????				      include	"vcs.h"
      1  8400 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8400 ????
      3  8400 ????						; VCS.H
      4  8400 ????						; Version 1.05, 13/November/2003
      5  8400 ????
      6  8400 ????	       00 69	   VERSION_VCS =	105
      7  8400 ????
      8  8400 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  8400 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  8400 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  8400 ????						;
     12  8400 ????						; This file defines hardware registers and memory mapping for the
     13  8400 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  8400 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  8400 ????						; available at at http://www.atari2600.org/dasm
     16  8400 ????						;
     17  8400 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  8400 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  8400 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  8400 ????						; with your views.  Please contribute, if you think you can improve this
     21  8400 ????						; file!
     22  8400 ????						;
     23  8400 ????						; Latest Revisions...
     24  8400 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  8400 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  8400 ????						;			    This will allow conditional code to verify VCS.H being
     27  8400 ????						;			    used for code assembly.
     28  8400 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  8400 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  8400 ????						;			 mirrored reading/writing differences.	This is more a 
     31  8400 ????						;			 readability issue, and binary compatibility with disassembled
     32  8400 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  8400 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  8400 ????						;			 which was broken by the use of segments in this file, as
     35  8400 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  8400 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  8400 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  8400 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  8400 ????						;						   it is safe to leave it undefined, and the base address will
     40  8400 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  8400 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  8400 ????						;			  - register definitions are now generated through assignment
     43  8400 ????						;			    in uninitialised segments.	This allows a changeable base
     44  8400 ????						;			    address architecture.
     45  8400 ????						; 1.0	22/MAR/2003		Initial release
     46  8400 ????
     47  8400 ????
     48  8400 ????						;-------------------------------------------------------------------------------
     49  8400 ????
     50  8400 ????						; TIA_BASE_ADDRESS
     51  8400 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  8400 ????						; Normally 0, the base address should (externally, before including this file)
     53  8400 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  8400 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  8400 ????						; < $40 as a bankswitch.
     56  8400 ????
     57  8400 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  8400 ????			  -TIA_BASE_ADDRESS =	0
     59  8400 ????				      ENDIF
     60  8400 ????
     61  8400 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  8400 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  8400 ????						; *OR* by declaring the label before including this file, eg:
     64  8400 ????						; TIA_BASE_ADDRESS = $40
     65  8400 ????						;   include "vcs.h"
     66  8400 ????
     67  8400 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  8400 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  8400 ????						; for the mirrored ROM hardware registers.
     70  8400 ????
     71  8400 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  8400 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  8400 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  8400 ????
     75  8400 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  8400 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  8400 ????				      ENDIF
     78  8400 ????
     79  8400 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  8400 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  8400 ????				      ENDIF
     82  8400 ????
     83  8400 ????						;-------------------------------------------------------------------------------
     84  8400 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  8400 ????				      SEG
    201  8400 ????
    202  8400 ????						; EOF
------- FILE c:\Users\danie\Documents\GitHub\atari-blitz2600\blitz2600.bas.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  8400 ????				      include	"macro.h"
      1  8400 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8400 ????
      3  8400 ????						; MACRO.H
      4  8400 ????						; Version 1.05, 13/NOVEMBER/2003
      5  8400 ????
      6  8400 ????	       00 69	   VERSION_MACRO =	105
      7  8400 ????
      8  8400 ????						;
      9  8400 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  8400 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  8400 ????						;
     12  8400 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  8400 ????						; It is distributed as a companion machine-specific support package
     14  8400 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  8400 ????						; available at at http://www.atari2600.org/dasm
     16  8400 ????						;
     17  8400 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  8400 ????						; contents, or would like to add something, please write to me
     19  8400 ????						; (atari2600@taswegian.com) with your contribution.
     20  8400 ????						;
     21  8400 ????						; Latest Revisions...
     22  8400 ????						;
     23  8400 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  8400 ????						;			    This will allow conditional code to verify MACRO.H being
     25  8400 ????						;			    used for code assembly.
     26  8400 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  8400 ????						;
     28  8400 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  8400 ????						;
     30  8400 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  8400 ????						;			   (standardised macro for vertical synch code)
     32  8400 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  8400 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  8400 ????						; 1.0	22/MAR/2003		Initial release
     35  8400 ????
     36  8400 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  8400 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  8400 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  8400 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  8400 ????						;   registers and require them to be defined first).
     41  8400 ????
     42  8400 ????						; Available macros...
     43  8400 ????						;   SLEEP n		 - sleep for n cycles
     44  8400 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  8400 ????						;   CLEAN_START	 - set machine to known state on startup
     46  8400 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  8400 ????
     48  8400 ????						;-------------------------------------------------------------------------------
     49  8400 ????						; SLEEP duration
     50  8400 ????						; Original author: Thomas Jentzsch
     51  8400 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  8400 ????						; useful for code where precise timing is required.
     53  8400 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  8400 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  8400 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  8400 ????
     57  8400 ????				      MAC	sleep
     58  8400 ????			   .CYCLES    SET	{1}
     59  8400 ????
     60  8400 ????				      IF	.CYCLES < 2
     61  8400 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  8400 ????				      ERR
     63  8400 ????				      ENDIF
     64  8400 ????
     65  8400 ????				      IF	.CYCLES & 1
     66  8400 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  8400 ????				      nop	0
     68  8400 ????				      ELSE
     69  8400 ????				      bit	VSYNC
     70  8400 ????				      ENDIF
     71  8400 ????			   .CYCLES    SET	.CYCLES - 3
     72  8400 ????				      ENDIF
     73  8400 ????
     74  8400 ????				      REPEAT	.CYCLES / 2
     75  8400 ????				      nop
     76  8400 ????				      REPEND
     77  8400 ????				      ENDM		;usage: SLEEP n (n>1)
     78  8400 ????
     79  8400 ????						;-------------------------------------------------------------------------------
     80  8400 ????						; VERTICAL_SYNC
     81  8400 ????						; Original author: Manuel Polik
     82  8400 ????						; Inserts the code required for a proper 3 scannline 
     83  8400 ????						; vertical sync sequence
     84  8400 ????						;
     85  8400 ????						; Note: Alters the accumulator
     86  8400 ????						;
     87  8400 ????						; IN:
     88  8400 ????						; OUT: A = 1
     89  8400 ????
     90  8400 ????				      MAC	vertical_sync
     91  8400 ????				      LDA	#$02	; A = VSYNC enable
     92  8400 ????				      STA	WSYNC	; Finish current line
     93  8400 ????				      STA	VSYNC	; Start vertical sync
     94  8400 ????				      STA	WSYNC	; 1st line vertical sync
     95  8400 ????				      STA	WSYNC	; 2nd line vertical sync
     96  8400 ????				      LSR		; A = VSYNC disable
     97  8400 ????				      STA	WSYNC	; 3rd line vertical sync
     98  8400 ????				      STA	VSYNC	; Stop vertical sync
     99  8400 ????				      ENDM
    100  8400 ????
    101  8400 ????						;-------------------------------------------------------------------------------
    102  8400 ????						; CLEAN_START
    103  8400 ????						; Original author: Andrew Davie
    104  8400 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  8400 ????						; Sets stack pointer to $FF, and all registers to 0
    106  8400 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  8400 ????						; Use as very first section of code on boot (ie: at reset)
    108  8400 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  8400 ????
    110  8400 ????				      MAC	clean_start
    111  8400 ????				      sei
    112  8400 ????				      cld
    113  8400 ????
    114  8400 ????				      ldx	#0
    115  8400 ????				      txa
    116  8400 ????				      tay
    117  8400 ????			   .CLEAR_STACK dex
    118  8400 ????				      txs
    119  8400 ????				      pha
    120  8400 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  8400 ????
    122  8400 ????				      ENDM
    123  8400 ????
    124  8400 ????						;-------------------------------------------------------
    125  8400 ????						; SET_POINTER
    126  8400 ????						; Original author: Manuel Rotschkar
    127  8400 ????						;
    128  8400 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  8400 ????						;
    130  8400 ????						; Usage: SET_POINTER pointer, address
    131  8400 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  8400 ????						;
    133  8400 ????						; Note: Alters the accumulator, NZ flags
    134  8400 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  8400 ????						; IN 2: absolute address
    136  8400 ????
    137  8400 ????				      MAC	set_pointer
    138  8400 ????			   .POINTER   SET	{1}
    139  8400 ????			   .ADDRESS   SET	{2}
    140  8400 ????
    141  8400 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  8400 ????				      STA	.POINTER	; Store in pointer
    143  8400 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  8400 ????				      STA	.POINTER+1	; Store in pointer+1
    145  8400 ????
    146  8400 ????				      ENDM
    147  8400 ????
    148  8400 ????						; EOF
------- FILE c:\Users\danie\Documents\GitHub\atari-blitz2600\blitz2600.bas.asm
------- FILE DPCplus.h LEVEL 2 PASS 3
      0  8400 ????				      include	"DPCplus.h"
      1  8400 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8400 ????
      3  8400 ????						; DPCplus.H - Display Processor Chip Plus Definitions
      4  8400 ????						; Chris Walton, Fred Quimby, Darrell Spice 2010
      5  8400 ????						; Version 0.00
      6  8400 ????
      7  8400 ????						; DPC Base Address
      8  8400 ????			  -	      IFNCONST	DPC_BASE_ADDRESS
      9  8400 ????			  -DPC_BASE_ADDRESS =	$1000
     10  8400 ????				      ENDIF
     11  8400 ????
     12  8400 ????						; DPC Read Base
     13  8400 ????			  -	      IFNCONST	DPC_BASE_READ_ADDRESS
     14  8400 ????			  -DPC_BASE_READ_ADDRESS =	DPC_BASE_ADDRESS
     15  8400 ????				      ENDIF
     16  8400 ????
     17  8400 ????						; DPC Write Base
     18  8400 ????			  -	      IFNCONST	DPC_BASE_WRITE_ADDRESS
     19  8400 ????			  -DPC_BASE_WRITE_ADDRESS =	DPC_BASE_ADDRESS+$28
     20  8400 ????				      ENDIF
     21  8400 ????
     22 U1028 ????				      SEG.U	DPC_REGISTERS_READ
     23 U1000					      ORG	DPC_BASE_READ_ADDRESS
     24 U1000
     25 U1000							;****************************************
     26 U1000							; DPC+ Read Registers
     27 U1000							;****************************************
     28 U1000							;
     29 U1000							;----------------------------------------
     30 U1000							; Random Numbers
     31 U1000							;----------------------------------------
     32 U1000							; DPC+ provides a 32 bit LFSR (Linear feedback shift register)
     33 U1000							; which is used as a random number generator.	Each individual byte of the
     34 U1000							; random number will return values from 0-255.  The random numbers will follow
     35 U1000							; an exact sequence, so it's best to clock them at least once per frame even if 
     36 U1000							; you don't need the value (this allows the amount of time it takes the user to
     37 U1000							; start the game to select a random starting point in the sequence)
     38 U1000							;----------------------------------------
     39 U1000		       00	   RANDOM0NEXT DS	1	; $00 clock next 32 bit number and returns byte 0
     40 U1001		       00	   RANDOM0PRIOR DS	1	; $01 clock prior 32 bit number and returns byte 0
     41 U1002		       00	   RANDOM1    DS	1	; $02 returns byte 1 of random number w/out clock
     42 U1003		       00	   RANDOM2    DS	1	; $03 returns byte 2 of random number w/out clock
     43 U1004		       00	   RANDOM3    DS	1	; $04 returns byte 3 of random number w/out clock
     44 U1005
     45 U1005							;----------------------------------------
     46 U1005							; Music Fetcher
     47 U1005							;----------------------------------------
     48 U1005							; When generating music, this value must be read every single scanline and
     49 U1005							; stored into AUDV0.
     50 U1005							;----------------------------------------
     51 U1005		       00	   AMPLITUDE  DS	1	; $05
     52 U1006
     53 U1006							;----------------------------------------
     54 U1006							; Reserved
     55 U1006							;----------------------------------------
     56 U1006		       00		      DS	1	; $06
     57 U1007		       00		      DS	1	; $07
     58 U1008
     59 U1008							;----------------------------------------
     60 U1008							; Data Fetcher
     61 U1008							;----------------------------------------
     62 U1008							; There are 8 Data Fetchers which are used to access data stored in the Display
     63 U1008							; Data bank.  Before using, you must point the Data Fetcher at the data to read
     64 U1008							; via DFxLOW and DFxHI.  After each read the Data Fetcher will update to point
     65 U1008							; to the next byte of data to return.
     66 U1008							;
     67 U1008							; psuedo code* to point Data Fetcher 1 to the color data
     68 U1008							;	lda #<(ColorDataPosition - HowFarDownScreen)
     69 U1008							;	sta DF1LOW
     70 U1008							;	lda #>(ColorDataPosition - HowFarDownScreen)
     71 U1008							;	sta DF1HI 
     72 U1008							;	....
     73 U1008							; then in the kernel read the Data Fetcher and update the color, takes 7 cycles
     74 U1008							;	LDA DF1DATA
     75 U1008							;	STA COLUP0
     76 U1008							;
     77 U1008							; * see DPCplus.asm for actual code
     78 U1008							;----------------------------------------
     79 U1008		       00	   DF0DATA    DS	1	; $08
     80 U1009		       00	   DF1DATA    DS	1	; $09
     81 U100a		       00	   DF2DATA    DS	1	; $0A
     82 U100b		       00	   DF3DATA    DS	1	; $0B
     83 U100c		       00	   DF4DATA    DS	1	; $0C
     84 U100d		       00	   DF5DATA    DS	1	; $0D
     85 U100e		       00	   DF6DATA    DS	1	; $0E
     86 U100f		       00	   DF7DATA    DS	1	; $0F
     87 U1010
     88 U1010							;----------------------------------------
     89 U1010							; Data Fetcher, Windowed
     90 U1010							;----------------------------------------
     91 U1010							; The 8 Data Fetchers can also be read in a "windowed" mode, which is most
     92 U1010							; commonly used to update sprites.  To use windowed mode, point the Data
     93 U1010							; Fetcher the same as above, but then also set the Top and Bottom of the
     94 U1010							; Window using DFxTOP and DFxBOT.  When reading via the DFxDATAW registers, a 0
     95 U1010							; value will be returned for anything that's outside of the window.
     96 U1010							;
     97 U1010							; psuedo code to point Data Fetcher0 to the sprite data
     98 U1010							;	lda #<(SpriteDataPosition - HowFarDownScreen)
     99 U1010							;	sta DF0LOW
    100 U1010							;	lda #>(SpriteDataPosition - HowFarDownScreen)
    101 U1010							;	sta DF0HI
    102 U1010							;	
    103 U1010							; set the window for Data Fetcher 0
    104 U1010							;	lda #<(SpriteDataPosition - 1)
    105 U1010							;	sta DF0TOP
    106 U1010							;	lda #<(SpriteDataPosition + ImageHeight)
    107 U1010							;	sta DF0BOT
    108 U1010							;	....
    109 U1010							; then in the kernel read the Data Fetcher and update the sprite, takes 7 cycles
    110 U1010							;	LDA DF0DATAW
    111 U1010							;	STA GRP0
    112 U1010							;----------------------------------------
    113 U1010		       00	   DF0DATAW   DS	1	; $10
    114 U1011		       00	   DF1DATAW   DS	1	; $11
    115 U1012		       00	   DF2DATAW   DS	1	; $12
    116 U1013		       00	   DF3DATAW   DS	1	; $13
    117 U1014		       00	   DF4DATAW   DS	1	; $14
    118 U1015		       00	   DF5DATAW   DS	1	; $15
    119 U1016		       00	   DF6DATAW   DS	1	; $16
    120 U1017		       00	   DF7DATAW   DS	1	; $17
    121 U1018
    122 U1018							;----------------------------------------
    123 U1018							; Fractional Data Fetcher
    124 U1018							;----------------------------------------
    125 U1018							; Another 8 Data Fetchers exist which work differently than the first 8.
    126 U1018							; These allow you to fractionally increment the Data Fetcher so a single
    127 U1018							; value can be read a set number of times before advancing to the next value.
    128 U1018							; This is commonly used to draw asymmetrical playfields without needing to 
    129 U1018							; use 1200 bytes of data (200 scanlines * 6 playfield updates).
    130 U1018							; Before using, you must point the Fractional Data Fetcher at the data to read
    131 U1018							; via DFxFRACLOW and DFxFRACHI.  You must also set the increment value via
    132 U1018							; DFxFRACINC.
    133 U1018							;
    134 U1018							; Set pointer
    135 U1018							;	LDA #<PlayfieldPF0l
    136 U1018							;	STA DF0FRACLOW
    137 U1018							;	... repeat for PF1l, PF2l, PF0r, PF1r and PF2r
    138 U1018							;	lda #>PlayFieldPF0l
    139 U1018							;	STA DF0FRACHI
    140 U1018							;	... repeat for PF1l, PF2l, PF0r, PF1r and PF2r
    141 U1018							; Set the increment to repeat the value for x reads
    142 U1018							;	LDA #(256/x)
    143 U1018							;	STA DF0FRACINC
    144 U1018							;	 STA DF1FRACINC
    145 U1018							;	... repeat for 2-5
    146 U1018							;
    147 U1018							; Special Condition - IF you want to increment the pointer after every read 
    148 U1018							; (just like the normal Data Fetcher), then use the following to set the
    149 U1018							; increment AND prime the Fractional Data Fetcher
    150 U1018							;	LDA #255
    151 U1018							;	STA DF0FRACINC
    152 U1018							;	 STA DF1FRACINC
    153 U1018							;	... repeat for 2-5
    154 U1018							;	LDA DF0FRACDATA - priming read (first value will be read twice)
    155 U1018							;	LDA DF1FRACDATA - priming read (first value will be read twice)
    156 U1018							;	... repeat for 2-5
    157 U1018							;
    158 U1018							; then in the kernel read the Fractional Data Fetchers and update the playfield
    159 U1018							;	LDA DF0FRACDATA
    160 U1018							;	STA PF0
    161 U1018							;	LDA PF1FRACDATA
    162 U1018							;	STA PF1
    163 U1018							;	... repeat for Data Fetchers 2-5, putting them in PF2, PF0, PF1 and PF2
    164 U1018							;----------------------------------------
    165 U1018		       00	   DF0FRACDATA DS	1	; $18
    166 U1019		       00	   DF1FRACDATA DS	1	; $19
    167 U101a		       00	   DF2FRACDATA DS	1	; $1A
    168 U101b		       00	   DF3FRACDATA DS	1	; $1B
    169 U101c		       00	   DF4FRACDATA DS	1	; $1C
    170 U101d		       00	   DF5FRACDATA DS	1	; $1D
    171 U101e		       00	   DF6FRACDATA DS	1	; $1E
    172 U101f		       00	   DF7FRACDATA DS	1	; $1F
    173 U1020
    174 U1020							;----------------------------------------
    175 U1020							; Data Fetcher Window Flag
    176 U1020							;----------------------------------------
    177 U1020							; The Data Fetcher Window Flag allows you to dual-purpose the first four
    178 U1020							; Data Fetchers.  The Window is not required when a Data Fetcher is used to
    179 U1020							; update a sprite's color.  The Flag will return $FF if it's within the window,
    180 U1020							; or 0 if it's not - this value can be used to control the display of the ball
    181 U1020							; and missiles. The Data Fetcher will NOT increment when reading the flag.
    182 U1020							;
    183 U1020							; psuedo code to point Data Fetcher 1 to the color data
    184 U1020							;	lda #<(ColorDataPosition - HowFarDownScreen)
    185 U1020							;	sta DF1LOW
    186 U1020							;	lda #>(ColorDataPosition - HowFarDownScreen)
    187 U1020							;	sta DF1HI
    188 U1020							;
    189 U1020							; set the window based on the missile's Y position and height (number of
    190 U1020							; scanlines to draw missile on)
    191 U1020							;	lda #<(ColorDataPosition + MissileYposition - 1)
    192 U1020							;	sta DF1TOP
    193 U1020							;	lda #<(ColorDataPosition + MissileYposition + MissileHeight)
    194 U1020							;	sta DF1BOT
    195 U1020							;
    196 U1020							; then in the kernel read the Data Fetcher and update the color, then read the
    197 U1020							; flag and update the missile
    198 U1020							;	LDA DF1DATA
    199 U1020							;	STA COLUP0
    200 U1020							;	LDA DF1FLAG
    201 U1020							;	STA ENAM0
    202 U1020							;----------------------------------------
    203 U1020		       00	   DF0FLAG    DS	1	; $20
    204 U1021		       00	   DF1FLAG    DS	1	; $21
    205 U1022		       00	   DF2FLAG    DS	1	; $22
    206 U1023		       00	   DF3FLAG    DS	1	; $23
    207 U1024
    208 U1024							;----------------------------------------
    209 U1024							; Reserved
    210 U1024							;----------------------------------------
    211 U1024		       00		      DS	1	; $24
    212 U1025		       00		      DS	1	; $25
    213 U1026		       00		      DS	1	; $26
    214 U1027		       00		      DS	1	; $27
    215 U1028
    216 U1028
    217 U1080 ????				      SEG.U	DPC_REGISTERS_WRITE
    218 U1028					      ORG	DPC_BASE_WRITE_ADDRESS
    219 U1028
    220 U1028							;****************************************
    221 U1028							; SECTION 2 - DPC+ Write Registers
    222 U1028							;****************************************
    223 U1028							;
    224 U1028							;----------------------------------------
    225 U1028							; Fractional Data Fetcher, Low Pointer
    226 U1028							;----------------------------------------
    227 U1028							; These are used in conjunction with DFxFRACHI to point a Fractional Data
    228 U1028							; Fetcher to the data to read.  For usage, see "Fractional Data Fetcher"
    229 U1028							; in SECTION 1.
    230 U1028							;----------------------------------------
    231 U1028		       00	   DF0FRACLOW DS	1	; $28
    232 U1029		       00	   DF1FRACLOW DS	1	; $29
    233 U102a		       00	   DF2FRACLOW DS	1	; $2A
    234 U102b		       00	   DF3FRACLOW DS	1	; $2B
    235 U102c		       00	   DF4FRACLOW DS	1	; $2C
    236 U102d		       00	   DF5FRACLOW DS	1	; $2D
    237 U102e		       00	   DF6FRACLOW DS	1	; $2E
    238 U102f		       00	   DF7FRACLOW DS	1	; $2F
    239 U1030
    240 U1030							;----------------------------------------
    241 U1030							; Fractional Data Fetcher, High Pointer
    242 U1030							;----------------------------------------
    243 U1030							; These are used in conjunction with DFxFRACLOW to point a Fractional Data
    244 U1030							; Fetcher to the data to read.  For usage, see "Fractional Data Fetcher"
    245 U1030							; in SECTION 1.
    246 U1030							;
    247 U1030							; NOTE: for only the lower 4 bits are used.
    248 U1030							;----------------------------------------
    249 U1030		       00	   DF0FRACHI  DS	1	; $30
    250 U1031		       00	   DF1FRACHI  DS	1	; $31
    251 U1032		       00	   DF2FRACHI  DS	1	; $32
    252 U1033		       00	   DF3FRACHI  DS	1	; $33
    253 U1034		       00	   DF4FRACHI  DS	1	; $34
    254 U1035		       00	   DF5FRACHI  DS	1	; $35 
    255 U1036		       00	   DF6FRACHI  DS	1	; $36 
    256 U1037		       00	   DF7FRACHI  DS	1	; $37 
    257 U1038
    258 U1038							;----------------------------------------
    259 U1038							; Fractional Data Fetcher, Increment
    260 U1038							;----------------------------------------
    261 U1038							; These are used to set the increment amount for the Fractional Data Fetcher.
    262 U1038							; To increment pointer after every Xth read use int(256/X)
    263 U1038							; For usage, see "Fractional Data Fetcher" in SECTION 1.
    264 U1038							;----------------------------------------
    265 U1038		       00	   DF0FRACINC DS	1	; $38
    266 U1039		       00	   DF1FRACINC DS	1	; $39
    267 U103a		       00	   DF2FRACINC DS	1	; $3A
    268 U103b		       00	   DF3FRACINC DS	1	; $3B
    269 U103c		       00	   DF4FRACINC DS	1	; $3C
    270 U103d		       00	   DF5FRACINC DS	1	; $3D
    271 U103e		       00	   DF6FRACINC DS	1	; $3E
    272 U103f		       00	   DF7FRACINC DS	1	; $3F
    273 U1040
    274 U1040							;----------------------------------------
    275 U1040							; Data Fetcher, Window Top
    276 U1040							;----------------------------------------
    277 U1040							; These are used with DFxBOT to define the Data Fetcher Window
    278 U1040							; For usage, see "Data Fetcher, Windowed" in SECTION 1.
    279 U1040							;----------------------------------------
    280 U1040		       00	   DF0TOP     DS	1	; $40
    281 U1041		       00	   DF1TOP     DS	1	; $41
    282 U1042		       00	   DF2TOP     DS	1	; $42
    283 U1043		       00	   DF3TOP     DS	1	; $43
    284 U1044		       00	   DF4TOP     DS	1	; $44
    285 U1045		       00	   DF5TOP     DS	1	; $45
    286 U1046		       00	   DF6TOP     DS	1	; $46
    287 U1047		       00	   DF7TOP     DS	1	; $47
    288 U1048
    289 U1048							;----------------------------------------
    290 U1048							; Data Fetcher, Window Bottom
    291 U1048							;----------------------------------------
    292 U1048							; These are used with DFxTOP to define the Data Fetcher Window
    293 U1048							; For usage, see "Data Fetcher, Windowed" in SECTION 1.
    294 U1048							;----------------------------------------
    295 U1048		       00	   DF0BOT     DS	1	; $48
    296 U1049		       00	   DF1BOT     DS	1	; $49
    297 U104a		       00	   DF2BOT     DS	1	; $4A
    298 U104b		       00	   DF3BOT     DS	1	; $4B
    299 U104c		       00	   DF4BOT     DS	1	; $4C
    300 U104d		       00	   DF5BOT     DS	1	; $4D
    301 U104e		       00	   DF6BOT     DS	1	; $4E
    302 U104f		       00	   DF7BOT     DS	1	; $4F
    303 U1050
    304 U1050							;----------------------------------------
    305 U1050							; Data Fetcher, Low Pointer
    306 U1050							;----------------------------------------
    307 U1050							; These are used in conjunction with DFxHI to point a Data Fetcher to the data
    308 U1050							; to read.  For usage, see "Data Fetcher" in SECTION 1.
    309 U1050							;----------------------------------------
    310 U1050		       00	   DF0LOW     DS	1	; $50
    311 U1051		       00	   DF1LOW     DS	1	; $51
    312 U1052		       00	   DF2LOW     DS	1	; $52
    313 U1053		       00	   DF3LOW     DS	1	; $53
    314 U1054		       00	   DF4LOW     DS	1	; $54
    315 U1055		       00	   DF5LOW     DS	1	; $55
    316 U1056		       00	   DF6LOW     DS	1	; $56
    317 U1057		       00	   DF7LOW     DS	1	; $57
    318 U1058
    319 U1058							;----------------------------------------
    320 U1058							; Fast Fetch Mode
    321 U1058							;----------------------------------------
    322 U1058							; Fast Fetch Mode enables the fastest way to read DPC+ registers.  Normal
    323 U1058							; reads use LDA Absolute addressing (LDA DF0DATA) which takes 4 cycles to
    324 U1058							; process.  Fast Fetch Mode intercepts LDA Immediate addressing (LDA #<DF0DATA)
    325 U1058							; which takes only 2 cycles!  Only immediate values < $28 are intercepted
    326 U1058							; 
    327 U1058							; set Fast Fetch Mode
    328 U1058							;	LDA #0
    329 U1058							;	STA FASTFETCH
    330 U1058							;
    331 U1058							; then use immediate mode to read the registers, takes just 5 cycles to update
    332 U1058							; any TIA register
    333 U1058							;
    334 U1058							;	LDA #<DF0DATA
    335 U1058							;	STA GRP0
    336 U1058							;
    337 U1058							; when done, turn off Fast Fetch Mode using any non-zero value
    338 U1058							;	LDA #$FF
    339 U1058							;	STA FASTFETCH
    340 U1058							;
    341 U1058							; NOTE: if you forget to turn off FASTFETCH mode, then code like this will not
    342 U1058							;	 work as you expect
    343 U1058							;	LDA #0	; returns a RANDOM NUMBER, not 0.
    344 U1058							;	STA COLUPF
    345 U1058							;----------------------------------------
    346 U1058		       00	   FASTFETCH  DS	1	; $58
    347 U1059
    348 U1059							;----------------------------------------
    349 U1059							; Function Support
    350 U1059							;----------------------------------------
    351 U1059							; Currently only Function 255 is defined, and it is used to call user
    352 U1059							; written ARM routines (or C code compiled for the ARM processor.)
    353 U1059							;
    354 U1059							; PARAMETER is not used by function 255, it may be used by future functions.
    355 U1059							; 
    356 U1059							; call custom ARM routine
    357 U1059							;	LDA #$FF
    358 U1059							;	STA CALLFUNCTION
    359 U1059							;
    360 U1059							; A custom ARM demo will be released in the near future
    361 U1059							;----------------------------------------
    362 U1059		       00	   PARAMETER  DS	1	; $59
    363 U105a		       00	   CALLFUNCTION DS	1	; $5A
    364 U105b
    365 U105b							;----------------------------------------
    366 U105b							; Reserved
    367 U105b							;----------------------------------------
    368 U105b		       00		      DS	1	; $5B	 ; reserved
    369 U105c		       00		      DS	1	; $5C	 ; reserved
    370 U105d
    371 U105d							;----------------------------------------
    372 U105d							; Waveforms
    373 U105d							;----------------------------------------
    374 U105d							; Waveforms are 32 byte tables that define a waveform.  Waveforms must be 32
    375 U105d							; byte aligned, and can only be stored in the 4K Display Data Bank. You MUST
    376 U105d							; define an "OFF" waveform,  comprised of all zeros.  The sum of all waveforms
    377 U105d							; being played should be <= 15, so typically you'll use a maximum of 5 for any
    378 U105d							; given value.
    379 U105d							;
    380 U105d							; Valid values are 0-127 and point to the 4K Display Data bank.  The formula
    381 U105d							; (* & $1fff)/32 as shown below will calculate the value for you
    382 U105d							;
    383 U105d							;
    384 U105d							; example waveforms
    385 U105d							;	align 32		; forces the waveform to a 32 byte boundary
    386 U105d							;SOUND_OFF = (* & $1fff)/32	; calculates waveform pointer
    387 U105d							;	.byte 0,0,0,0,0,0,0,0
    388 U105d							;	.byte 0,0,0,0,0,0,0,0
    389 U105d							;	.byte 0,0,0,0,0,0,0,0
    390 U105d							;	.byte 0,0,0,0,0,0,0,0 
    391 U105d							; 
    392 U105d							;	align 32
    393 U105d							;SINE_WAVE = (* & $1fff)/32
    394 U105d							;	.byte 3,3,3,4,4,5,5,5
    395 U105d							;	.byte 5,5,5,5,4,4,3,3
    396 U105d							;	.byte 3,2,2,1,1,0,0,0
    397 U105d							;	.byte 0,0,0,0,1,1,2,2 
    398 U105d							;
    399 U105d							; usage, set voice 0 to Sine Wave, set voice 1 & 2 off
    400 U105d							;	LDA #SINE_WAVE
    401 U105d							;	STA WAVEFORM0
    402 U105d							;	LDA #SOUND_OFF
    403 U105d							;	STA WAVEFORM1
    404 U105d							;	STA WAVEFORM2	
    405 U105d							;----------------------------------------
    406 U105d		       00	   WAVEFORM0  DS	1	; $5D
    407 U105e		       00	   WAVEFORM1  DS	1	; $5E
    408 U105f		       00	   WAVEFORM2  DS	1	; $5F
    409 U1060
    410 U1060							;----------------------------------------
    411 U1060							; Data Fetcher Push (stack)
    412 U1060							;----------------------------------------
    413 U1060							; The Data Fetchers can also be used to update the contents of the 4K
    414 U1060							; Display Data bank.  Point the Data Fetcher to the data to change,
    415 U1060							; then Push to it.  The Data Fetcher's pointer will be decremented BEFORE
    416 U1060							; the data is written.
    417 U1060							;
    418 U1060							; point Data Fetcher 1 to the sprite data
    419 U1060							;	lda #<DisplayData
    420 U1060							;	sta DF1LOW
    421 U1060							;	lda #>DisplayData
    422 U1060							;	sta DF1HI 
    423 U1060							;
    424 U1060							; then update it
    425 U1060							;	LDA #$FF
    426 U1060							;	STA DF1PUSH ; changes data at DisplayData - 1
    427 U1060							;	LDA #$81
    428 U1060							;	STA DF1OUSH ; changes data at DisplayData - 2
    429 U1060							;----------------------------------------
    430 U1060		       00	   DF0PUSH    DS	1	; $60
    431 U1061		       00	   DF1PUSH    DS	1	; $61
    432 U1062		       00	   DF2PUSH    DS	1	; $62
    433 U1063		       00	   DF3PUSH    DS	1	; $63
    434 U1064		       00	   DF4PUSH    DS	1	; $64
    435 U1065		       00	   DF5PUSH    DS	1	; $65
    436 U1066		       00	   DF6PUSH    DS	1	; $66
    437 U1067		       00	   DF7PUSH    DS	1	; $67
    438 U1068
    439 U1068							;----------------------------------------
    440 U1068							; Data Fetcher, High Pointer
    441 U1068							;----------------------------------------
    442 U1068							; These are used in conjunction with DFxLOW to point a Data Fetcher to the data
    443 U1068							; to read.  For usage, see "Data Fetcher" in SECTION 1.
    444 U1068							;----------------------------------------
    445 U1068		       00	   DF0HI      DS	1	; $68
    446 U1069		       00	   DF1HI      DS	1	; $69
    447 U106a		       00	   DF2HI      DS	1	; $6A
    448 U106b		       00	   DF3HI      DS	1	; $6B
    449 U106c		       00	   DF4HI      DS	1	; $6C
    450 U106d		       00	   DF5HI      DS	1	; $6D 
    451 U106e		       00	   DF6HI      DS	1	; $6E 
    452 U106f		       00	   DF7HI      DS	1	; $6F 
    453 U1070
    454 U1070							;----------------------------------------
    455 U1070							; Random Number Initialization
    456 U1070							;----------------------------------------
    457 U1070							; The random number generate defaults to a value that spells out DPC+.
    458 U1070							; Store any value to RRESET to set the random number back to DPC+, or you
    459 U1070							; can use RWRITE0-3 to change the 32 bit value to anything you desire.
    460 U1070							;
    461 U1070							; reset random number
    462 U1070							;	LDA #0
    463 U1070							;	STA RRESET
    464 U1070							;
    465 U1070							; set a specific random number (spells out 2600)
    466 U1070							;	LDA #$32
    467 U1070							;	STA RWRITE0
    468 U1070							;	LDA #$36
    469 U1070							;	STA RWRITE1
    470 U1070							;	LDA #$30
    471 U1070							;	STA RWRITE2
    472 U1070							;	STA RWRITE3
    473 U1070							;
    474 U1070							; NOTE: do not set all 4 bytes to 0, as that will disable the generator.
    475 U1070							;----------------------------------------
    476 U1070		       00	   RRESET     DS	1	; $70
    477 U1071		       00	   RWRITE0    DS	1	; $71
    478 U1072		       00	   RWRITE1    DS	1	; $72
    479 U1073		       00	   RWRITE2    DS	1	; $73
    480 U1074		       00	   RWRITE3    DS	1	; $74
    481 U1075
    482 U1075							;----------------------------------------
    483 U1075							; Notes
    484 U1075							;----------------------------------------
    485 U1075							; These are used to select a value from the frequency table to play.
    486 U1075							; The default table, store in DPC_frequencies.h, only defines frequencies
    487 U1075							; for 1-88, which cover the keys of a piano.  You are free to add additional
    488 U1075							; frequencies from 88-255.  Piano keys are defined at the end of this file
    489 U1075							;
    490 U1075							; set voice 0 to middle C
    491 U1075							;	LDA #C4
    492 U1075							;	STA NOTE0
    493 U1075							;
    494 U1075							; Note: if you are using ARM USER CODE then you can only use notes to 128.
    495 U1075							;----------------------------------------
    496 U1075		       00	   NOTE0      DS	1	; $75
    497 U1076		       00	   NOTE1      DS	1	; $76
    498 U1077		       00	   NOTE2      DS	1	; $77
    499 U1078
    500 U1078							;----------------------------------------
    501 U1078							; Data Fetcher Write (queue)
    502 U1078							;----------------------------------------
    503 U1078							; The Data Fetchers can also be used to update the contents of the 4K
    504 U1078							; Display Data bank.  Point the Data Fetcher to the data to change,
    505 U1078							; then Write to it  The Data Fetcher's pointer will be incremented AFTER
    506 U1078							; the data is written.
    507 U1078							;
    508 U1078							; point Data Fetcher 1 to the sprite data
    509 U1078							;	lda #<SpriteData
    510 U1078							;	sta DF1LOW
    511 U1078							;	lda #>SpriteData
    512 U1078							;	sta DF1HI 
    513 U1078							;
    514 U1078							; then update it
    515 U1078							;	LDA #$FF
    516 U1078							;	STA DF1WRITE ; changes data at SpriteData
    517 U1078							;	LDA #$81
    518 U1078							;	STA DF1WRITE ; changes data at SpriteData + 1
    519 U1078							;----------------------------------------
    520 U1078		       00	   DF0WRITE   DS	1	; $78
    521 U1079		       00	   DF1WRITE   DS	1	; $79
    522 U107a		       00	   DF2WRITE   DS	1	; $7A
    523 U107b		       00	   DF3WRITE   DS	1	; $7B
    524 U107c		       00	   DF4WRITE   DS	1	; $7C
    525 U107d		       00	   DF5WRITE   DS	1	; $7D
    526 U107e		       00	   DF6WRITE   DS	1	; $7E
    527 U107f		       00	   DF7WRITE   DS	1	; $7F
    528 U1080
    529 U1080							;-------------------------------------------------------------------------------
    530 U1080							; The following required for back-compatibility with code which does not use
    531 U1080							; segments.
    532 U1080
    533  8400 ????				      SEG
------- FILE c:\Users\danie\Documents\GitHub\atari-blitz2600\blitz2600.bas.asm
------- FILE DPCplusbB.h LEVEL 2 PASS 3
      0  8400 ????				      include	"DPCplusbB.h"
      1  8400 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8400 ????
      3 U00f5 ????				      SEG.U	vars
      4 U0080					      org	$80
      5 U0080		       00	   player0x   ds	1
      6 U0081		       00	   topP1x     ds	1
      7 U0082		       00	   missile0x  ds	1
      8 U0083		       00	   missile1x  ds	1
      9 U0084		       00	   ballx      ds	1
     10 U0085
     11 U0085		       00 00 00 00*SpriteGfxIndex ds	9
     12 U008e
     13 U008e		       00	   spritedisplay ds	1
     14 U008f
     15 U008f		       00	   player0xcoll ds	1	; to detect p0x colls
     16 U0090		       00	   NewSpriteX ds	1	;		X position
     17 U0090		       00 90	   player1x   =	NewSpriteX
     18 U0091		       00	   player2x   ds	1
     19 U0092		       00	   player3x   ds	1
     20 U0093		       00	   player4x   ds	1
     21 U0094		       00	   player5x   ds	1
     22 U0095		       00	   player6x   ds	1
     23 U0096		       00	   player7x   ds	1
     24 U0097		       00	   player8x   ds	1
     25 U0098		       00	   player9x   ds	1
     26 U0099
     27 U0099		       00	   player0y   ds	1
     28 U009a		       00	   NewSpriteY ds	1	;		Y position
     29 U009a		       00 9a	   player1y   =	NewSpriteY
     30 U009b		       00	   player2y   ds	1
     31 U009c		       00	   player3y   ds	1
     32 U009d		       00	   player4y   ds	1
     33 U009e		       00	   player5y   ds	1
     34 U009f		       00	   player6y   ds	1
     35 U00a0		       00	   player7y   ds	1
     36 U00a1		       00	   player8y   ds	1
     37 U00a2		       00	   player9y   ds	1
     38 U00a3
     39 U00a3		       00 00	   player0color ds	2
     40 U00a5
     41 U00a5		       00	   player0height ds	1
     42 U00a6		       00	   player1height ds	1
     43 U00a7		       00	   player2height ds	1
     44 U00a8		       00	   player3height ds	1
     45 U00a9		       00	   player4height ds	1
     46 U00aa		       00	   player5height ds	1
     47 U00ab		       00	   player6height ds	1
     48 U00ac		       00	   player7height ds	1
     49 U00ad		       00	   player8height ds	1
     50 U00ae		       00	   player9height ds	1
     51 U00af
     52 U00af		       00	   _NUSIZ1    ds	1
     53 U00b0		       00	   NUSIZ2     ds	1
     54 U00b1		       00	   NUSIZ3     ds	1
     55 U00b2		       00	   NUSIZ4     ds	1
     56 U00b3		       00	   NUSIZ5     ds	1
     57 U00b4		       00	   NUSIZ6     ds	1
     58 U00b5		       00	   NUSIZ7     ds	1
     59 U00b6		       00	   NUSIZ8     ds	1
     60 U00b7		       00	   NUSIZ9     ds	1
     61 U00b8
     62 U00b8		       00 00 00    score      ds	3
     63 U00bb		       00	   COLUM0     ds	1
     64 U00bc		       00	   COLUM1     ds	1
     65 U00bd		       00	   player0pointerlo ds	1
     66 U00be		       00	   player0pointerhi ds	1
     67 U00bf
     68 U00bf		       00 85	   RAMcopybegin =	SpriteGfxIndex
     69 U00bf		       00 3a	   RAMcopylength =	*-RAMcopybegin
     70 U00bf
     71 U00bf		       00	   missile0y  ds	1
     72 U00c0		       00	   missile1y  ds	1
     73 U00c1		       00	   bally      ds	1
     74 U00c2
     75 U00c2		       00	   missile0height ds	1
     76 U00c3		       00	   missile1height ds	1
     77 U00c4		       00	   ballheight ds	1
     78 U00c5
     79 U00c5		       00	   statusbarlength ds	1	; needed?
     80 U00c5		       00 c5	   aux3       =	statusbarlength
     81 U00c6
     82 U00c6		       00	   lifecolor  ds	1
     83 U00c6		       00 c6	   pfscorecolor =	lifecolor
     84 U00c7		       00	   aux4       ds	1
     85 U00c8
     86 U00c8		       00	   lifepointer ds	1
     87 U00c9		       00	   lives      ds	1
     88 U00c9		       00 c8	   pfscore1   =	lifepointer
     89 U00c9		       00 c9	   pfscore2   =	lives
     90 U00c9		       00 c8	   aux5       =	pfscore1
     91 U00c9		       00 c9	   aux6       =	pfscore2
     92 U00ca
     93 U00ca		       00	   playfieldpos ds	1
     94 U00cb
     95 U00cb		       00	   temp1      ds	1	; used in sprite flickering
     96 U00cc		       00	   temp2      ds	1	;are obliterated when drawscreen is called.
     97 U00cd		       00	   temp3      ds	1
     98 U00ce		       00	   temp4      ds	1
     99 U00cf		       00	   temp5      ds	1
    100 U00d0		       00	   temp6      ds	1
    101 U00d0		       00 81	   temp7      =	topP1x	; This is used to aid in bankswitching
    102 U00d1
    103 U00d1		       00	   A	      ds	1
    104 U00d1		       00 d1	   a	      =	A
    105 U00d2		       00	   B	      ds	1
    106 U00d2		       00 d2	   b	      =	B
    107 U00d3		       00	   C	      ds	1
    108 U00d3		       00 d3	   c	      =	C
    109 U00d4		       00	   D	      ds	1
    110 U00d4		       00 d4	   d	      =	D
    111 U00d5		       00	   E	      ds	1
    112 U00d5		       00 d5	   e	      =	E
    113 U00d6		       00	   F	      ds	1
    114 U00d6		       00 d6	   f	      =	F
    115 U00d7		       00	   G	      ds	1
    116 U00d7		       00 d7	   g	      =	G
    117 U00d8		       00	   H	      ds	1
    118 U00d8		       00 d8	   h	      =	H
    119 U00d9		       00	   I	      ds	1
    120 U00d9		       00 d9	   i	      =	I
    121 U00da		       00	   J	      ds	1
    122 U00da		       00 da	   j	      =	J
    123 U00db		       00	   K	      ds	1
    124 U00db		       00 db	   k	      =	K
    125 U00dc		       00	   L	      ds	1
    126 U00dc		       00 dc	   l	      =	L
    127 U00dd		       00	   M	      ds	1
    128 U00dd		       00 dd	   m	      =	M
    129 U00de		       00	   N	      ds	1
    130 U00de		       00 de	   n	      =	N
    131 U00df		       00	   O	      ds	1
    132 U00df		       00 df	   o	      =	O
    133 U00e0		       00	   P	      ds	1
    134 U00e0		       00 e0	   p	      =	P
    135 U00e1		       00	   Q	      ds	1
    136 U00e1		       00 e1	   q	      =	Q
    137 U00e2		       00	   R	      ds	1
    138 U00e2		       00 e2	   r	      =	R
    139 U00e3		       00	   S	      ds	1
    140 U00e3		       00 e3	   s	      =	S
    141 U00e4		       00	   T	      ds	1
    142 U00e4		       00 e4	   t	      =	T
    143 U00e5		       00	   U	      ds	1
    144 U00e5		       00 e5	   u	      =	U
    145 U00e6		       00	   V	      ds	1
    146 U00e6		       00 e6	   v	      =	V
    147 U00e7		       00	   W	      ds	1
    148 U00e7		       00 e7	   w	      =	W
    149 U00e8		       00	   X	      ds	1
    150 U00e8		       00 e8	   x	      =	X
    151 U00e9		       00	   Y	      ds	1
    152 U00e9		       00 e9	   y	      =	Y
    153 U00ea		       00	   Z	      ds	1
    154 U00ea		       00 ea	   z	      =	Z
    155 U00eb		       00	   scorecolor ds	1
    156 U00ec
    157 U00ec		       00	   var0       ds	1
    158 U00ed		       00	   var1       ds	1
    159 U00ee		       00	   var2       ds	1
    160 U00ef		       00	   var3       ds	1
    161 U00f0		       00	   var4       ds	1
    162 U00f1		       00	   var5       ds	1
    163 U00f2		       00	   var6       ds	1
    164 U00f3		       00	   var7       ds	1
    165 U00f4		       00	   var8       ds	1
    166 U00f5
 free ram: 0
    167 U00f5					      echo	"free ram:",($f5-*)d
    168 U00f5
    169 U00f5		       00 f6	   stack1     =	$f6
    170 U00f5		       00 f7	   stack2     =	$f7
    171 U00f5		       00 f8	   stack3     =	$f8
    172 U00f5		       00 f9	   stack4     =	$f9
    173 U00f5							; the stack bytes above may be used in the kernel
    174 U00f5							; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    175 U00f5
    176 U00f5					      MAC	return
    177 U00f5					      ifnconst	bankswitch
    178 U00f5					      rts
    179 U00f5					      else
    180 U00f5					      jmp	BS_return
    181 U00f5					      endif
    182 U00f5					      ENDM		; auto-return from either a regular or bankswitched module
    183  8400 ????				      seg
    184  8400 ????	       10 00	   rand       =	RANDOM0NEXT
    185  8400 ????	       00 d3	   KERNEL_LINES =	178*76/64	; warning: not all values will work
    186  8400 ????	       00 a7	   OVERSCAN_LINES =	128+33*76/64	; again, not all values work
    187  8400 ????	       d1 a4	   C_function =	FETCHER_BEGIN
    188  8400 ????	       d1 a8	   CcodeData  =	C_function + 4
    189  8400 ????	       d1 e2	   playerpointers =	CcodeData + RAMcopylength
    190  8400 ????	       d2 08	   P1GFX      =	playerpointers + 38
    191  8400 ????	       d3 08	   P1COLOR    =	P1GFX + 256
    192  8400 ????	       d4 08	   P0GFX      =	P1COLOR + 256
    193  8400 ????	       d5 08	   P0COLOR    =	P0GFX + 256
    194  8400 ????	       d6 08	   PF1L       =	P0COLOR + 256
    195  8400 ????	       d7 08	   PF2L       =	PF1L + 256
    196  8400 ????	       d8 08	   PF1R       =	PF2L + 256
    197  8400 ????	       d9 08	   PF2R       =	PF1R + 256
    198  8400 ????	       da 08	   PFCOLS     =	PF2R + 256
    199  8400 ????	       db 08	   JUMPTABLELO =	PFCOLS + 256
    200  8400 ????	       db 14	   JUMPTABLEHI =	JUMPTABLELO + 12
    201  8400 ????	       db 20	   P1HMP      =	JUMPTABLEHI + 12
    202  8400 ????	       db 2d	   P1SKIP     =	P1HMP + 13
    203  8400 ????	       db 39	   NUSIZREFP  =	P1SKIP + 12
    204  8400 ????	       db 45	   scoredata  =	NUSIZREFP + 12
    205  8400 ????	       db a5	   BKCOLS     =	scoredata + 96
    206  8400 ????	       dc a5	   STACKbegin =	BKCOLS + 256
    207  8400 ????	       dd a5	   USERSTACK  =	STACKbegin + 256	; stack starts here and goes down!!!!
 DPC free RAM= 603
    208  8400 ????				      echo	"DPC free RAM=",($1000-(USERSTACK&$0FFF))d
------- FILE c:\Users\danie\Documents\GitHub\atari-blitz2600\blitz2600.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 3
      0  8400 ????				      include	"2600basic_variable_redefs.h"
      1  8400 ????						; This file contains variable mapping and other information for the current project.
      2  8400 ????
      3  8400 ????	       00 20	   bscode_length =	32
      4  8400 ????	       00 07	   bs_mask    =	7
      5  8400 ????	       00 1c	   bankswitch =	28
      6  8400 ????	       1f f6	   bankswitch_hotspot =	$1FF6
      7  8400 ????	       00 02	   multisprite =	2
      8  8400 ????	       00 2b	   vblank_time =	43
      9  8400 ????	       00 25	   overscan_time =	37
------- FILE c:\Users\danie\Documents\GitHub\atari-blitz2600\blitz2600.bas.asm
      9  0400					      ORG	$400
     10  0400					      RORG	$0
     11  0400					      incbin	DPCplus.arm
     12  1000					      ORG	$1000
     13  1000					      RORG	$1000
     14  1000					      incbin	custom/bin/custom2.bin
     15  1894							; assume custom2.bin > 128 bytes
     16  1894							; repeat $80
     17  1894							; .byte 0
     18  1894							; repend
     19  1894							; Provided under the CC0 license. See the included LICENSE.txt for details.
     20  1894
     21  1894							; feel free to modify the score graphics - just keep each digit 8 high
     22  1894							; and keep the conditional compilation stuff intact
     23  1894				  -	      ifconst	ROM2k
     24  1894				  -	      ORG	$F7AC-8
     25  1894					      else
     26  1894					      ifconst	bankswitch
     27  1894				  -	      if	bankswitch == 8
     28  1894				  -	      ORG	$2F94-bscode_length
     29  1894				  -	      RORG	$FF94-bscode_length
     30  1894					      endif
     31  1894				  -	      if	bankswitch == 16
     32  1894				  -	      ORG	$4F94-bscode_length
     33  1894				  -	      RORG	$FF94-bscode_length
     34  1894					      endif
     35  1894				  -	      if	bankswitch == 32
     36  1894				  -	      ORG	$8F94-bscode_length
     37  1894				  -	      RORG	$FF94-bscode_length
     38  1894					      endif
     39  1894				  -	      if	bankswitch == 64
     40  1894				  -	      ORG	$10F80-bscode_length
     41  1894				  -	      RORG	$1FF80-bscode_length
     42  1894					      endif
     43  1894				  -	      else
     44  1894				  -	      ORG	$FF9C
     45  1894					      endif
     46  1894					      endif
     47  1894
     48  1894							; font equates
     49  1894		       00 01	   .21stcentury =	1
     50  1894		       00 02	   alarmclock =	2
     51  1894		       00 03	   handwritten =	3
     52  1894		       00 04	   interrupted =	4
     53  1894		       00 05	   retroputer =	5
     54  1894		       00 06	   whimsey    =	6
     55  1894		       00 07	   tiny       =	7
     56  1894		       00 08	   hex	      =	8
     57  1894
     58  1894				  -	      ifconst	font
     59  1894				  -	      if	font == hex
     60  1894				  -	      ORG	. - 48
     61  1894				  -	      endif
     62  1894					      endif
     63  1894
     64  1894				   scoretable
     65  1894
     66  1894				  -	      ifconst	font
     67  1894				  -	      if	font == .21stcentury
     68  1894				  -	      include	"score_graphics.asm.21stcentury"
     69  1894				  -	      endif
     70  1894				  -	      if	font == alarmclock
     71  1894				  -	      include	"score_graphics.asm.alarmclock"
     72  1894				  -	      endif
     73  1894				  -	      if	font == handwritten
     74  1894				  -	      include	"score_graphics.asm.handwritten"
     75  1894				  -	      endif
     76  1894				  -	      if	font == interrupted
     77  1894				  -	      include	"score_graphics.asm.interrupted"
     78  1894				  -	      endif
     79  1894				  -	      if	font == retroputer
     80  1894				  -	      include	"score_graphics.asm.retroputer"
     81  1894				  -	      endif
     82  1894				  -	      if	font == whimsey
     83  1894				  -	      include	"score_graphics.asm.whimsey"
     84  1894				  -	      endif
     85  1894				  -	      if	font == tiny
     86  1894				  -	      include	"score_graphics.asm.tiny"
     87  1894				  -	      endif
     88  1894				  -	      if	font == hex
     89  1894				  -	      include	"score_graphics.asm.hex"
     90  1894				  -	      endif
     91  1894					      else		; default font
     92  1894
     93  1894		       3c		      .byte.b	%00111100
     94  1895		       66		      .byte.b	%01100110
     95  1896		       66		      .byte.b	%01100110
     96  1897		       66		      .byte.b	%01100110
     97  1898		       66		      .byte.b	%01100110
     98  1899		       66		      .byte.b	%01100110
     99  189a		       66		      .byte.b	%01100110
    100  189b		       3c		      .byte.b	%00111100
    101  189c
    102  189c		       7e		      .byte.b	%01111110
    103  189d		       18		      .byte.b	%00011000
    104  189e		       18		      .byte.b	%00011000
    105  189f		       18		      .byte.b	%00011000
    106  18a0		       18		      .byte.b	%00011000
    107  18a1		       38		      .byte.b	%00111000
    108  18a2		       18		      .byte.b	%00011000
    109  18a3		       08		      .byte.b	%00001000
    110  18a4
    111  18a4		       7e		      .byte.b	%01111110
    112  18a5		       60		      .byte.b	%01100000
    113  18a6		       60		      .byte.b	%01100000
    114  18a7		       3c		      .byte.b	%00111100
    115  18a8		       06		      .byte.b	%00000110
    116  18a9		       06		      .byte.b	%00000110
    117  18aa		       46		      .byte.b	%01000110
    118  18ab		       3c		      .byte.b	%00111100
    119  18ac
    120  18ac		       3c		      .byte.b	%00111100
    121  18ad		       46		      .byte.b	%01000110
    122  18ae		       06		      .byte.b	%00000110
    123  18af		       06		      .byte.b	%00000110
    124  18b0		       1c		      .byte.b	%00011100
    125  18b1		       06		      .byte.b	%00000110
    126  18b2		       46		      .byte.b	%01000110
    127  18b3		       3c		      .byte.b	%00111100
    128  18b4
    129  18b4		       0c		      .byte.b	%00001100
    130  18b5		       0c		      .byte.b	%00001100
    131  18b6		       7e		      .byte.b	%01111110
    132  18b7		       4c		      .byte.b	%01001100
    133  18b8		       4c		      .byte.b	%01001100
    134  18b9		       2c		      .byte.b	%00101100
    135  18ba		       1c		      .byte.b	%00011100
    136  18bb		       0c		      .byte.b	%00001100
    137  18bc
    138  18bc		       3c		      .byte.b	%00111100
    139  18bd		       46		      .byte.b	%01000110
    140  18be		       06		      .byte.b	%00000110
    141  18bf		       06		      .byte.b	%00000110
    142  18c0		       3c		      .byte.b	%00111100
    143  18c1		       60		      .byte.b	%01100000
    144  18c2		       60		      .byte.b	%01100000
    145  18c3		       7e		      .byte.b	%01111110
    146  18c4
    147  18c4		       3c		      .byte.b	%00111100
    148  18c5		       66		      .byte.b	%01100110
    149  18c6		       66		      .byte.b	%01100110
    150  18c7		       66		      .byte.b	%01100110
    151  18c8		       7c		      .byte.b	%01111100
    152  18c9		       60		      .byte.b	%01100000
    153  18ca		       62		      .byte.b	%01100010
    154  18cb		       3c		      .byte.b	%00111100
    155  18cc
    156  18cc		       30		      .byte.b	%00110000
    157  18cd		       30		      .byte.b	%00110000
    158  18ce		       30		      .byte.b	%00110000
    159  18cf		       18		      .byte.b	%00011000
    160  18d0		       0c		      .byte.b	%00001100
    161  18d1		       06		      .byte.b	%00000110
    162  18d2		       42		      .byte.b	%01000010
    163  18d3		       3e		      .byte.b	%00111110
    164  18d4
    165  18d4		       3c		      .byte.b	%00111100
    166  18d5		       66		      .byte.b	%01100110
    167  18d6		       66		      .byte.b	%01100110
    168  18d7		       66		      .byte.b	%01100110
    169  18d8		       3c		      .byte.b	%00111100
    170  18d9		       66		      .byte.b	%01100110
    171  18da		       66		      .byte.b	%01100110
    172  18db		       3c		      .byte.b	%00111100
    173  18dc
    174  18dc		       3c		      .byte.b	%00111100
    175  18dd		       46		      .byte.b	%01000110
    176  18de		       06		      .byte.b	%00000110
    177  18df		       3e		      .byte.b	%00111110
    178  18e0		       66		      .byte.b	%01100110
    179  18e1		       66		      .byte.b	%01100110
    180  18e2		       66		      .byte.b	%01100110
    181  18e3		       3c		      .byte.b	%00111100
    182  18e4
    183  18e4				  -	      ifnconst	DPC_kernel_options
    184  18e4				  -
    185  18e4				  -	      .byte	%00000000
    186  18e4				  -	      .byte	%00000000
    187  18e4				  -	      .byte	%00000000
    188  18e4				  -	      .byte	%00000000
    189  18e4				  -	      .byte	%00000000
    190  18e4				  -	      .byte	%00000000
    191  18e4				  -	      .byte	%00000000
    192  18e4				  -	      .byte	%00000000
    193  18e4				  -
    194  18e4					      endif
    195  18e4
    196  18e4					      endif
    197  18e4
    198  18e4				  -	      ifconst	ROM2k
    199  18e4				  -	      ORG	$F7FC
    200  18e4					      else
    201  18e4					      ifconst	bankswitch
    202  18e4				  -	      if	bankswitch == 8
    203  18e4				  -	      ORG	$2FF4-bscode_length
    204  18e4				  -	      RORG	$FFF4-bscode_length
    205  18e4					      endif
    206  18e4				  -	      if	bankswitch == 16
    207  18e4				  -	      ORG	$4FF4-bscode_length
    208  18e4				  -	      RORG	$FFF4-bscode_length
    209  18e4					      endif
    210  18e4				  -	      if	bankswitch == 32
    211  18e4				  -	      ORG	$8FF4-bscode_length
    212  18e4				  -	      RORG	$FFF4-bscode_length
    213  18e4					      endif
    214  18e4				  -	      if	bankswitch == 64
    215  18e4				  -	      ORG	$10FE0-bscode_length
    216  18e4				  -	      RORG	$1FFE0-bscode_length
    217  18e4					      endif
    218  18e4				  -	      else
    219  18e4				  -	      ORG	$FFFC
    220  18e4					      endif
    221  18e4					      endif
    222  18e4							; Provided under the CC0 license. See the included LICENSE.txt for details.
    223  18e4
    224  18e4				   start
    225  18e4		       78		      sei
    226  18e5		       d8		      cld
    227  18e6		       a0 00		      ldy	#0
    228  18e8		       a5 d0		      lda	$D0
    229  18ea		       c9 2c		      cmp	#$2C	;check RAM location #1
    230  18ec		       d0 07		      bne	MachineIs2600
    231  18ee		       a5 d1		      lda	$D1
    232  18f0		       c9 a9		      cmp	#$A9	;check RAM location #2
    233  18f2		       d0 01		      bne	MachineIs2600
    234  18f4		       88		      dey
    235  18f5				   MachineIs2600
    236  18f5		       a2 00		      ldx	#0
    237  18f7		       8a		      txa
    238  18f8				   clearmem
    239  18f8		       e8		      inx
    240  18f9		       9a		      txs
    241  18fa		       48		      pha
    242  18fb		       d0 fb		      bne	clearmem
    243  18fd		       84 cb		      sty	temp1
    244  18ff		       a2 08		      ldx	#8
    245  1901		       86 ca		      stx	playfieldpos
    246  1903		       8e 58 10 	      stx	FASTFETCH
    247  1906		       a2 08		      ldx	#8
    248  1908		       a9 e0		      lda	#224
    249  190a				   inityloop
    250  190a		       95 9a		      sta	player1y,x
    251  190c		       ca		      dex
    252  190d		       10 fb		      bpl	inityloop
    253  190f
    254  190f		       a9 01		      lda	#1
    255  1911		       85 0a		      sta	CTRLPF
    256  1913		       ad 84 02 	      lda	INTIM
    257  1916		       8d 71 10 	      sta	RWRITE0
    258  1919		       a9 00		      lda	#0
    259  191b		       8d 38 10 	      STA	DF0FRACINC
    260  191e		       8d 39 10 	      STA	DF1FRACINC
    261  1921		       8d 3a 10 	      STA	DF2FRACINC
    262  1924		       8d 3b 10 	      STA	DF3FRACINC
    263  1927		       8d 3c 10 	      STA	DF4FRACINC
    264  192a		       8d 3e 10 	      STA	DF6FRACINC
    265  192d		       a9 a5		      lda	#<USERSTACK
    266  192f		       8d 57 10 	      STA	DF7LOW
    267  1932		       a9 0d		      lda	#(>USERSTACK) & $0F
    268  1934		       8d 6f 10 	      STA	DF7HI
    269  1937		       a9 ff		      lda	#255
    270  1939		       8d 5a 10 	      sta	CALLFUNCTION	; zero-fill fetcher
    271  193c
    272  193c		       a9 1f		      lda	#>(game-1)
    273  193e		       48		      pha
    274  193f		       a9 90		      lda	#<(game-1)
    275  1941		       48		      pha
    276  1942		       48		      pha
    277  1943		       48		      pha
    278  1944		       a2 01		      ldx	#1
    279  1946		       4c ee df 	      jmp	BS_jsr
    280  1949				   drawscreen
    281  1949		       a9 01		      lda	#1
    282  194b		       85 2c		      sta	CXCLR
    283  194d		       85 09		      sta	COLUBK	; REVENG - don't start with the lastline color
    284  194f
    285  194f				   fufu
    286  194f		       ad 84 02 	      lda	INTIM
    287  1952		       30 fb		      bmi	fufu
    288  1954
      0  1954					      VERTICAL_SYNC
      1  1954		       a9 02		      LDA	#$02
      2  1956		       85 02		      STA	WSYNC
      3  1958		       85 00		      STA	VSYNC
      4  195a		       85 02		      STA	WSYNC
      5  195c		       85 02		      STA	WSYNC
      6  195e		       4a		      LSR
      7  195f		       85 02		      STA	WSYNC
      8  1961		       85 00		      STA	VSYNC
    290  1963
    291  1963		       a9 a9		      lda	#41+128	;was 37 - do more w/c code
    292  1965		       8d 96 02 	      sta	TIM64T
    293  1968
    294  1968							; adjust for pfpos?
    295  1968
    296  1968							; set zero to properly enter C code
    297  1968		       a9 a4		      lda	#<C_function
    298  196a		       8d 50 10 	      sta	DF0LOW
    299  196d		       a9 01		      lda	#(>C_function) & $0F
    300  196f		       8d 68 10 	      sta	DF0HI
    301  1972		       a9 00		      lda	#0
    302  1974		       8d 78 10 	      sta	DF0WRITE
    303  1977
    304  1977							; REVENG - pass the number of vsprites we want...
    305  1977					      ifnconst	dpcspritemax
    306  1977				  -	      ifconst	readpaddle
    307  1977				  -	      lda	#8
    308  1977					      else
    309  1977		       a9 09		      lda	#9
    310  1979					      endif
    311  1979				  -	      else
    312  1979				  -	      lda	#dpcspritemax
    313  1979					      endif
    314  1979		       8d 78 10 	      sta	DF0WRITE
    315  197c
    316  197c		       a5 80		      lda	player0x
    317  197e		       85 8f		      sta	player0xcoll	; detect p0x colls
    318  1980
    319  1980							; copy RAM to fetcher for C-code
    320  1980		       a9 e2		      lda	#<(CcodeData + RAMcopylength)
    321  1982		       8d 50 10 	      sta	DF0LOW
    322  1985		       a9 01		      lda	#(>(CcodeData + RAMcopylength)) & $0F
    323  1987		       8d 68 10 	      sta	DF0HI
    324  198a		       a2 39		      ldx	#RAMcopylength-1
    325  198c				   copy2fetcherloop
    326  198c		       b5 85		      lda	RAMcopybegin,x
    327  198e		       8d 60 10 	      sta	DF0PUSH
    328  1991		       ca		      dex
    329  1992		       10 f8		      bpl	copy2fetcherloop
    330  1994
    331  1994		       a9 ff		      lda	#255
    332  1996		       8d 5a 10 	      sta	CALLFUNCTION
    333  1999
    334  1999							; copy modified data back (just need first 6 bytes, which is sprite sort data)
    335  1999		       a2 ed		      ldx	#256-19
    336  199b				   copyfromfetcherloop
    337  199b		       ad 08 10 	      lda	DF0DATA
    338  199e		       95 98		      sta	RAMcopybegin+19,x
    339  19a0		       e8		      inx
    340  19a1		       30 f8		      bmi	copyfromfetcherloop
    341  19a3
    342  19a3		       20 3a 1e 	      jsr	kernel_setup
    343  19a6		       85 02		      sta	WSYNC
    344  19a8		       a0 80		      ldy	#$80
    345  19aa		       84 20		      sty	HMP0
    346  19ac		       84 21		      sty	HMP1
    347  19ae		       84 22		      sty	HMM0
    348  19b0		       84 23		      sty	HMM1
    349  19b2		       84 24		      sty	HMBL
    350  19b4
    351  19b4							; run possible vblank bB code
    352  19b4				  -	      ifconst	vblank_bB_code
    353  19b4				  -	      jsr	vblank_bB_code
    354  19b4					      endif
    355  19b4
    356  19b4		       20 02 1d 	      jsr	set_fetchers
    357  19b7
    358  19b7		       a2 07		      ldx	#7
    359  19b9				   setloopfrac
    360  19b9		       bd 7d 1d 	      lda	dffraclow,x
    361  19bc		       9d 28 10 	      sta	DF0FRACLOW,x
    362  19bf		       bd 85 1d 	      lda	dffrachi,x
    363  19c2		       9d 30 10 	      sta	DF0FRACHI,x
    364  19c5		       ca		      dex
    365  19c6		       10 f1		      bpl	setloopfrac
    366  19c8							; lda #255
    367  19c8		       8e 3d 10 	      STx	DF5FRACINC	; x=255 right now
    368  19cb		       8e 3f 10 	      STx	DF7FRACINC
    369  19ce		       ad 1d 10 	      lda	DF5FRACDATA	; priming read
    370  19d1		       ad 1f 10 	      lda	DF7FRACDATA	; priming read
    371  19d4
    372  19d4		       a6 85		      ldx	SpriteGfxIndex
    373  19d6		       b5 af		      lda	_NUSIZ1,x	; top NUSIZ/REFP
    374  19d8		       85 05		      sta	NUSIZ1
    375  19da		       85 0c		      sta	REFP1
    376  19dc
    377  19dc							;REVENG - allow P0 to wrap at the top
    378  19dc				   startwrapfix
    379  19dc		       a9 ff		      lda	#255
    380  19de		       85 cc		      sta	temp2
    381  19e0		       18		      clc
    382  19e1		       a5 99		      lda	player0y
    383  19e3		       65 a5		      adc	player0height
    384  19e5		       38		      sec
    385  19e6		       c5 a5		      cmp	player0height
    386  19e8		       90 04		      bcc	skipwrapfix
    387  19ea		       a9 00		      lda	#0
    388  19ec		       85 cc		      sta	temp2
    389  19ee				   skipwrapfix
    390  19ee
    391  19ee		       38		      sec
    392  19ef		       a9 08		      lda	#<P0GFX
    393  19f1		       e5 99		      sbc	player0y
    394  19f3		       8d 52 10 	      sta	DF2LOW
    395  19f6		       a9 d4		      lda	#>P0GFX
    396  19f8							;sbc #0
    397  19f8		       e5 cc		      sbc	temp2
    398  19fa		       8d 6a 10 	      sta	DF2HI
    399  19fd		       a9 07		      lda	#<(P0GFX-1)
    400  19ff		       8d 42 10 	      sta	DF2TOP
    401  1a02		       38		      sec
    402  1a03		       65 a5		      adc	player0height
    403  1a05		       8d 4a 10 	      sta	DF2BOT
    404  1a08
    405  1a08							;REVENG - 1/2 of the COLUM0 fix. the rest is in main.c
    406  1a08		       a9 08		      lda	#<(P0COLOR)
    407  1a0a		       8d 50 10 	      sta	DF0LOW
    408  1a0d		       85 cc		      sta	temp2
    409  1a0f		       a9 d5		      lda	#>(P0COLOR)
    410  1a11		       8d 68 10 	      sta	DF0HI
    411  1a14
    412  1a14							; ball
    413  1a14		       a9 07		      lda	#<(P1GFX-1)
    414  1a16		       18		      clc
    415  1a17		       65 c1		      adc	bally
    416  1a19		       8d 43 10 	      sta	DF3TOP
    417  1a1c		       38		      sec
    418  1a1d		       65 c4		      adc	ballheight
    419  1a1f		       8d 4b 10 	      sta	DF3BOT
    420  1a22
    421  1a22							; missile0
    422  1a22		       a5 cc		      lda	temp2
    423  1a24		       18		      clc
    424  1a25		       65 bf		      adc	missile0y
    425  1a27		       8d 40 10 	      sta	DF0TOP
    426  1a2a		       38		      sec
    427  1a2b		       65 c2		      adc	missile0height
    428  1a2d		       8d 48 10 	      sta	DF0BOT
    429  1a30
    430  1a30
    431  1a30				   fuu
    432  1a30		       ad 84 02 	      lda	INTIM
    433  1a33		       30 fb		      bmi	fuu
    434  1a35		       85 02		      sta	WSYNC
    435  1a37							;     ldy #$80
    436  1a37							;     sty HMP0
    437  1a37							;     sty HMP1
    438  1a37							;     sty HMM0 
    439  1a37							;     sty HMM1
    440  1a37							;     sty HMBL
    441  1a37							; relocated code above prior to vblank, to allow for Cosmic Ark starfield
    442  1a37							; and/or skewed players
      0  1a37					      sleep	17
      1  1a37				   .CYCLES    SET	17
      2  1a37
      3  1a37				  -	      IF	.CYCLES < 2
      4  1a37				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1a37				  -	      ERR
      6  1a37					      ENDIF
      7  1a37
      8  1a37					      IF	.CYCLES & 1
      9  1a37					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1a37		       04 00		      nop	0
     11  1a39				  -	      ELSE
     12  1a39				  -	      bit	VSYNC
     13  1a39					      ENDIF
     14  1a39				   .CYCLES    SET	.CYCLES - 3
     15  1a39					      ENDIF
     16  1a39
     17  1a39					      REPEAT	.CYCLES / 2
     18  1a39		       ea		      nop
     17  1a39					      REPEND
     18  1a3a		       ea		      nop
     17  1a3a					      REPEND
     18  1a3b		       ea		      nop
     17  1a3b					      REPEND
     18  1a3c		       ea		      nop
     17  1a3c					      REPEND
     18  1a3d		       ea		      nop
     17  1a3d					      REPEND
     18  1a3e		       ea		      nop
     17  1a3e					      REPEND
     18  1a3f		       ea		      nop
     19  1a40					      REPEND
    444  1a40
    445  1a40		       a9 d3		      lda	#KERNEL_LINES
    446  1a42		       8d 96 02 	      sta	TIM64T
    447  1a45		       a9 01		      lda	#1
    448  1a47		       85 27		      sta	VDELBL
    449  1a49		       85 25		      sta	VDELP0
    450  1a4b
    451  1a4b							; missile1
    452  1a4b		       a9 07		      lda	#<(P1COLOR-1)
    453  1a4d		       18		      clc
    454  1a4e		       65 c0		      adc	missile1y
    455  1a50		       8d 41 10 	      sta	DF1TOP
    456  1a53		       38		      sec
    457  1a54		       65 c3		      adc	missile1height
    458  1a56		       8d 49 10 	      sta	DF1BOT
    459  1a59
    460  1a59		       a9 00		      lda	#0
    461  1a5b		       85 01		      sta	VBLANK
    462  1a5d		       8d 58 10 	      sta	FASTFETCH
    463  1a60							;sleep 7
    464  1a60		       a9 12		      lda	#<DF2DATAW	; REVENG - added so GRP0 is at TOP
    465  1a62		       85 1b		      STA	GRP0	; 36 (VDEL)   ; ""
      0  1a64					      sleep	2	; ""
      1  1a64				   .CYCLES    SET	2
      2  1a64
      3  1a64				  -	      IF	.CYCLES < 2
      4  1a64				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1a64				  -	      ERR
      6  1a64					      ENDIF
      7  1a64
      8  1a64				  -	      IF	.CYCLES & 1
      9  1a64				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1a64				  -	      nop	0
     11  1a64				  -	      ELSE
     12  1a64				  -	      bit	VSYNC
     13  1a64				  -	      ENDIF
     14  1a64				  -.CYCLES    SET	.CYCLES - 3
     15  1a64					      ENDIF
     16  1a64
     17  1a64					      REPEAT	.CYCLES / 2
     18  1a64		       ea		      nop
     19  1a65					      REPEND
    467  1a65
    468  1a65		       a9 18		      lda	#<DF0FRACDATA
    469  1a67		       85 0e		      sta	PF1	; (PF1L)
    470  1a69
    471  1a69							; enter at cycle ??
    472  1a69				   loop
    473  1a69		       a9 08		      lda	#<DF0DATA	;74
    474  1a6b		       85 06		      STA	COLUP0	; 1
    475  1a6d		       a9 09		      lda	#<DF1DATA	;3
    476  1a6f				   loop2
    477  1a6f		       85 07		      STA	COLUP1	; 6
    478  1a71		       a9 0b		      lda	#<DF3DATA
    479  1a73		       85 1c		      STA	GRP1	; 11
    480  1a75		       a9 20		      lda	#<DF0FLAG
    481  1a77		       85 1d		      STA	ENAM0	; 16
    482  1a79
    483  1a79		       a9 1e		      lda	#<DF6FRACDATA
    484  1a7b		       85 09		      sta	COLUBK	; 21
    485  1a7d		       a9 1c		      lda	#<DF4FRACDATA
    486  1a7f		       85 08		      sta	COLUPF	; 26
    487  1a81		       a9 19		      lda	#<DF1FRACDATA
    488  1a83		       85 0f		      sta	PF2	; 31 (PF2L)
    489  1a85				   loop3
    490  1a85		       a9 12		      lda	#<DF2DATAW
    491  1a87		       85 1b		      STA	GRP0	; 36 (VDEL)
    492  1a89		       a9 23		      lda	#<DF3FLAG
    493  1a8b		       85 1f		      STA	ENABL	; 41 (VDEL)
    494  1a8d		       a2 70		      ldx	#$70	;in case we get kernel 6
    495  1a8f		       a9 1a		      lda	#<DF2FRACDATA	;45
    496  1a91		       85 0f		      sta	PF2	; 48
    497  1a93		       84 21		      sty	HMP1	; 51 ; from prev. cycle: $80=nomove
    498  1a95		       a9 1b		      lda	#<DF3FRACDATA	;53
    499  1a97		       85 0e		      sta	PF1	; 56
    500  1a99		       a9 0c		      lda	#<DF4DATA	; 58 this is the repos info
    501  1a9b		       f0 4d		      beq	repo	;60/61
    502  1a9d				   norepo		; 60
    503  1a9d		       a8		      tay		; 62
    504  1a9e		       a9 08		      lda	#<DF0DATA	; 64
    505  1aa0
    506  1aa0		       ae 84 02 	      ldx	INTIM	; 68 timed for 192 lines
    507  1aa3		       f0 60		      beq	exitkernel	; 70/71
    508  1aa5		       85 2a		      sta	HMOVE	; 73
    509  1aa7
    510  1aa7		       85 06		      STA	COLUP0	; 0
    511  1aa9		       a9 09		      lda	#<DF1DATA	;2
    512  1aab		       85 07		      STA	COLUP1	;5
    513  1aad		       a9 0b		      lda	#<DF3DATA
    514  1aaf		       85 1c		      STA	GRP1	; 10
    515  1ab1		       a9 21		      lda	#<DF1FLAG
    516  1ab3		       85 1e		      STA	ENAM1	; 15
    517  1ab5		       a9 18		      lda	#<DF0FRACDATA
    518  1ab7		       85 0e		      sta	PF1	; 20 (PF1L)
    519  1ab9		       a9 19		      lda	#<DF1FRACDATA
    520  1abb		       85 0f		      sta	PF2	; 25 (PF2L)
    521  1abd		       a9 12		      lda	#<DF2DATAW
    522  1abf		       85 1b		      STA	GRP0	; 30 (VDEL)
    523  1ac1		       a9 23		      lda	#<DF3FLAG
    524  1ac3		       85 1f		      STA	ENABL	; 35 (VDEL)
    525  1ac5		       88		      dey		; 37
    526  1ac6		       8c 64 10 	      STY	DF4PUSH	; 41
    527  1ac9		       a0 80		      ldy	#$80	; 43 no movement next line
    528  1acb		       a9 1a		      lda	#<DF2FRACDATA	;45
    529  1acd		       85 0f		      sta	PF2	; 48
    530  1acf		       84 21		      sty	HMP1	; 51 ; from prev. cycle: $80=nomove
    531  1ad1		       a9 1b		      lda	#<DF3FRACDATA	;53
    532  1ad3		       85 0e		      sta	PF1	; 56
    533  1ad5				  -	      ifnconst	DPC_kernel_options
    534  1ad5				  -			;sleep 8 ; REVENG - timing is off - results in a garbled screen
    535  1ad5				  -	      sleep	5	; this is better
    536  1ad5					      else
    537  1ad5		       24 43		      bit	DPC_kernel_options
    538  1ad7					      if	(DPC_kernel_options > $3F)
    539  1ad7		       30 09		      bmi	COLfound
    540  1ad9				  -	      else
    541  1ad9				  -	      bpl	COLfound
    542  1ad9					      endif
    543  1ad9					      endif
    544  1ad9		       86 ce		      stx	temp4	; +3
    545  1adb
    546  1adb				   getbackearly
    547  1adb		       a9 18		      lda	#<DF0FRACDATA	; +2
    548  1add		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    549  1adf		       4c 69 5a 	      JMP	loop+$4000	; 72
    550  1ae2
    551  1ae2					      ifconst	DPC_kernel_options
    552  1ae2				   COLfound
    553  1ae2		       ad 18 10 	      lda	DF0FRACDATA
    554  1ae5		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    555  1ae7		       4c 69 5a 	      JMP	loop+$4000	; 72
    556  1aea					      endif
    557  1aea
    558  1aea				   repo
    559  1aea		       ac 1f 10 	      ldy	DF7FRACDATA	; 65
    560  1aed		       a9 18		      lda	#<DF0FRACDATA	; 67 preload PF1L for next line
    561  1aef				  -	      if	((>repo) > (>norepo))
    562  1aef				  -	      STA	PF1
    563  1aef					      else
    564  1aef		       8d 0e 00 	      STA.w	PF1	; 71 ; sta.w if page doesn't wrap
    565  1af2					      endif
    566  1af2		       a9 08		      lda	#<DF0DATA	;73
    567  1af4		       85 06		      STA	COLUP0	; 0
    568  1af6		       a9 09		      lda	#<DF1DATA
    569  1af8		       85 07		      STA	COLUP1	;5
    570  1afa		       a9 0b		      lda	#<DF3DATA
    571  1afc		       85 1c		      STA	GRP1	; 10
    572  1afe		       a9 21		      lda	#<DF1FLAG
    573  1b00		       85 1e		      STA	ENAM1	; 15
    574  1b02							; repos info holds HMMx
    575  1b02		       6c 0d 10 	      jmp	(DF5DATA)	; 20 grabs df6/df7=lo/hi
    576  1b05
    577  1b05				   exitkernel		; exit the kernel
    578  1b05		       20 c9 5e 	      jsr	scorekernel+$4000	; 1
    579  1b08				   exit
    580  1b08		       a2 ff		      ldx	#255
    581  1b0a		       8e 58 10 	      stx	FASTFETCH
    582  1b0d		       85 02		      sta	WSYNC
    583  1b0f		       a9 02		      lda	#2
    584  1b11		       85 01		      STA	VBLANK
    585  1b13		       a9 a7		      lda	#OVERSCAN_LINES
    586  1b15		       8d 96 02 	      sta	TIM64T
    587  1b18		       38		      sec
    588  1b19		       a9 d3		      lda	#KERNEL_LINES
    589  1b1b		       e5 ce		      sbc	temp4
    590  1b1d		       aa		      tax
    591  1b1e		       4a		      lsr
    592  1b1f		       4a		      lsr
    593  1b20		       85 cd		      sta	temp3	; div4
    594  1b22		       4a		      lsr
    595  1b23		       4a		      lsr
    596  1b24		       85 cc		      sta	temp2	; div16
    597  1b26		       4a		      lsr
    598  1b27		       85 cb		      sta	temp1	; div32
    599  1b29		       18		      clc
    600  1b2a		       8a		      txa
    601  1b2b		       65 cc		      adc	temp2
    602  1b2d		       65 cb		      adc	temp1
    603  1b2f		       38		      sec
    604  1b30		       e5 cd		      sbc	temp3
    605  1b32		       85 ce		      sta	temp4	; approx line of first pf coll
      0  1b34					      RETURN
      1  1b34				  -	      ifnconst	bankswitch
      2  1b34				  -	      rts
      3  1b34					      else
      4  1b34		       4c e0 df 	      jmp	BS_return
      5  1b37					      endif
    607  1b37
    608  1b37							; jmp exit
    609  1b37
    610  1b37							; kernels resp1 23/28/33/38/43/48/53/58/63/68/73
    611  1b37
    612  1b37				   kernel1
    613  1b37		       85 11		      sta	RESP1	; 23
    614  1b39		       a9 12		      lda	#<DF2DATAW
    615  1b3b		       85 1b		      STA	GRP0	; 28 (VDEL)
    616  1b3d		       a9 19		      lda	#<DF1FRACDATA
    617  1b3f		       85 0f		      STA	PF2	; 33
    618  1b41		       a9 23		      lda	#<DF3FLAG
    619  1b43		       85 1f		      STA	ENABL	; 38 (VDEL)
      0  1b45					      sleep	5
      1  1b45				   .CYCLES    SET	5
      2  1b45
      3  1b45				  -	      IF	.CYCLES < 2
      4  1b45				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1b45				  -	      ERR
      6  1b45					      ENDIF
      7  1b45
      8  1b45					      IF	.CYCLES & 1
      9  1b45					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1b45		       04 00		      nop	0
     11  1b47				  -	      ELSE
     12  1b47				  -	      bit	VSYNC
     13  1b47					      ENDIF
     14  1b47				   .CYCLES    SET	.CYCLES - 3
     15  1b47					      ENDIF
     16  1b47
     17  1b47					      REPEAT	.CYCLES / 2
     18  1b47		       ea		      nop
     19  1b48					      REPEND
    621  1b48		       a9 1a		      lda	#<DF2FRACDATA	;45
    622  1b4a		       85 0f		      sta	PF2	; 48
    623  1b4c		       a9 1b		      lda	#<DF3FRACDATA	;50
    624  1b4e		       85 0e		      sta	PF1	; 53
    625  1b50		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    626  1b52		       85 05		      STA	NUSIZ1	; 58
    627  1b54		       85 0c		      STA	REFP1	; 61
    628  1b56		       4c db 1a 	      jmp	getbackearly	;64
    629  1b59
    630  1b59				   kernel2
    631  1b59		       a9 12		      lda	#<DF2DATAW
    632  1b5b		       85 1b		      STA	GRP0	; 25 (VDEL)
    633  1b5d		       85 11		      sta	RESP1	;28
    634  1b5f		       a9 19		      lda	#<DF1FRACDATA
    635  1b61		       85 0f		      STA	PF2	; 33
    636  1b63		       a9 23		      lda	#<DF3FLAG
    637  1b65		       85 1f		      STA	ENABL	; 38 (VDEL)
      0  1b67					      sleep	5
      1  1b67				   .CYCLES    SET	5
      2  1b67
      3  1b67				  -	      IF	.CYCLES < 2
      4  1b67				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1b67				  -	      ERR
      6  1b67					      ENDIF
      7  1b67
      8  1b67					      IF	.CYCLES & 1
      9  1b67					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1b67		       04 00		      nop	0
     11  1b69				  -	      ELSE
     12  1b69				  -	      bit	VSYNC
     13  1b69					      ENDIF
     14  1b69				   .CYCLES    SET	.CYCLES - 3
     15  1b69					      ENDIF
     16  1b69
     17  1b69					      REPEAT	.CYCLES / 2
     18  1b69		       ea		      nop
     19  1b6a					      REPEND
    639  1b6a		       a9 1a		      lda	#<DF2FRACDATA	;45
    640  1b6c		       85 0f		      sta	PF2	; 48
    641  1b6e		       a9 1b		      lda	#<DF3FRACDATA	;50
    642  1b70		       85 0e		      sta	PF1	; 53
    643  1b72		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    644  1b74		       85 05		      STA	NUSIZ1
    645  1b76		       85 0c		      STA	REFP1
    646  1b78		       4c db 1a 	      jmp	getbackearly	;64
    647  1b7b
    648  1b7b				   kernel3
    649  1b7b		       a9 12		      lda	#<DF2DATAW
    650  1b7d		       85 1b		      STA	GRP0	; 25 (VDEL)
    651  1b7f		       a9 19		      lda	#<DF1FRACDATA
    652  1b81		       85 0f		      STA	PF2	; 30
    653  1b83		       85 11		      sta	RESP1	;33
    654  1b85		       a9 23		      lda	#<DF3FLAG
    655  1b87		       85 1f		      STA	ENABL	; 38 (VDEL)
      0  1b89					      sleep	5
      1  1b89				   .CYCLES    SET	5
      2  1b89
      3  1b89				  -	      IF	.CYCLES < 2
      4  1b89				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1b89				  -	      ERR
      6  1b89					      ENDIF
      7  1b89
      8  1b89					      IF	.CYCLES & 1
      9  1b89					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1b89		       04 00		      nop	0
     11  1b8b				  -	      ELSE
     12  1b8b				  -	      bit	VSYNC
     13  1b8b					      ENDIF
     14  1b8b				   .CYCLES    SET	.CYCLES - 3
     15  1b8b					      ENDIF
     16  1b8b
     17  1b8b					      REPEAT	.CYCLES / 2
     18  1b8b		       ea		      nop
     19  1b8c					      REPEND
    657  1b8c		       a9 1a		      lda	#<DF2FRACDATA	;45
    658  1b8e		       85 0f		      sta	PF2	; 48
    659  1b90		       a9 1b		      lda	#<DF3FRACDATA	;50
    660  1b92		       85 0e		      sta	PF1	; 53
    661  1b94		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    662  1b96		       85 05		      STA	NUSIZ1
    663  1b98		       85 0c		      STA	REFP1
    664  1b9a		       4c db 1a 	      JMP	getbackearly	; 64
    665  1b9d
    666  1b9d				   kernel4
    667  1b9d		       a9 12		      lda	#<DF2DATAW
    668  1b9f		       85 1b		      STA	GRP0	; 25 (VDEL)
    669  1ba1		       a9 23		      lda	#<DF3FLAG
    670  1ba3		       85 1f		      STA	ENABL	; 30(VDEL)
    671  1ba5		       a9 19		      lda	#<DF1FRACDATA
    672  1ba7		       85 0f		      STA	PF2	; 35
    673  1ba9		       85 11		      sta	RESP1	;38
      0  1bab					      sleep	5
      1  1bab				   .CYCLES    SET	5
      2  1bab
      3  1bab				  -	      IF	.CYCLES < 2
      4  1bab				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1bab				  -	      ERR
      6  1bab					      ENDIF
      7  1bab
      8  1bab					      IF	.CYCLES & 1
      9  1bab					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1bab		       04 00		      nop	0
     11  1bad				  -	      ELSE
     12  1bad				  -	      bit	VSYNC
     13  1bad					      ENDIF
     14  1bad				   .CYCLES    SET	.CYCLES - 3
     15  1bad					      ENDIF
     16  1bad
     17  1bad					      REPEAT	.CYCLES / 2
     18  1bad		       ea		      nop
     19  1bae					      REPEND
    675  1bae		       a9 1a		      lda	#<DF2FRACDATA	;45
    676  1bb0		       85 0f		      sta	PF2	; 48
    677  1bb2		       a9 1b		      lda	#<DF3FRACDATA	;50
    678  1bb4		       85 0e		      sta	PF1	; 53
    679  1bb6		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    680  1bb8		       85 05		      STA	NUSIZ1	; 58
    681  1bba		       85 0c		      STA	REFP1	; 61
    682  1bbc		       4c db 1a 	      JMP	getbackearly	; 64
    683  1bbf
    684  1bbf				   kernel5
    685  1bbf		       a9 12		      lda	#<DF2DATAW
    686  1bc1		       85 1b		      STA	GRP0	; (VDEL)
    687  1bc3		       a9 23		      lda	#<DF3FLAG
    688  1bc5		       85 1f		      STA	ENABL	; (VDEL)
    689  1bc7		       a9 19		      lda	#<DF1FRACDATA
    690  1bc9		       85 0f		      STA	PF2	; 35
      0  1bcb					      sleep	5
      1  1bcb				   .CYCLES    SET	5
      2  1bcb
      3  1bcb				  -	      IF	.CYCLES < 2
      4  1bcb				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1bcb				  -	      ERR
      6  1bcb					      ENDIF
      7  1bcb
      8  1bcb					      IF	.CYCLES & 1
      9  1bcb					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1bcb		       04 00		      nop	0
     11  1bcd				  -	      ELSE
     12  1bcd				  -	      bit	VSYNC
     13  1bcd					      ENDIF
     14  1bcd				   .CYCLES    SET	.CYCLES - 3
     15  1bcd					      ENDIF
     16  1bcd
     17  1bcd					      REPEAT	.CYCLES / 2
     18  1bcd		       ea		      nop
     19  1bce					      REPEND
    692  1bce		       85 11		      sta	RESP1	;43
    693  1bd0		       a9 1a		      lda	#<DF2FRACDATA	;45
    694  1bd2		       85 0f		      sta	PF2	; 48
    695  1bd4		       a9 1b		      lda	#<DF3FRACDATA	;50
    696  1bd6		       85 0e		      sta	PF1	; 53
    697  1bd8		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    698  1bda		       85 05		      STA	NUSIZ1
    699  1bdc		       85 0c		      STA	REFP1
    700  1bde		       4c db 1a 	      JMP	getbackearly	; 64
    701  1be1
    702  1be1				   kernel6
    703  1be1		       a9 12		      lda	#<DF2DATAW
    704  1be3		       85 1b		      STA	GRP0	; 25 (VDEL)
    705  1be5		       a9 23		      lda	#<DF3FLAG
    706  1be7		       85 1f		      STA	ENABL	; 30 (VDEL)
    707  1be9		       a9 19		      lda	#<DF1FRACDATA
    708  1beb		       85 0f		      STA	PF2	; 35
    709  1bed		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    710  1bef		       85 05		      STA	NUSIZ1	; 40
    711  1bf1		       85 0c		      STA	REFP1	; 43
    712  1bf3		       a9 1a		      lda	#<DF2FRACDATA	;45
    713  1bf5		       85 0f		      sta	PF2	; 48
    714  1bf7		       a9 1b		      lda	#<DF3FRACDATA	;50
    715  1bf9		       85 11		      sta	RESP1	;53
    716  1bfb							; do a move right by 15
    717  1bfb		       85 0e		      sta	PF1	; 56
    718  1bfd		       86 21		      stx	HMP1	; 59
    719  1bff		       a9 19		      lda	#<DF1FRACDATA
    720  1c01		       85 0f		      sta	PF2	; 64 (PF2L)
    721  1c03		       a9 18		      lda	#<DF0FRACDATA
    722  1c05		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    723  1c07		       a9 08		      lda	#<DF0DATA	; 71
    724  1c09		       85 2a		      sta	HMOVE	; 74 adjust to +15 right
    725  1c0b
    726  1c0b		       85 06		      STA	COLUP0	; 1
    727  1c0d		       a9 09		      lda	#<DF1DATA
    728  1c0f		       85 07		      sta	COLUP1	; 6
    729  1c11		       a9 0b		      lda	#<DF3DATA
    730  1c13		       85 1c		      STA	GRP1	; 11
    731  1c15		       a9 20		      lda	#<DF0FLAG
    732  1c17		       85 1d		      STA	ENAM0	; 16
    733  1c19		       a9 1e		      lda	#<DF6FRACDATA
    734  1c1b		       85 09		      STA	COLUBK	; 21
    735  1c1d		       a9 1c		      lda	#<DF4FRACDATA
    736  1c1f		       85 08		      sta	COLUPF	; 26
      0  1c21					      sleep	2
      1  1c21				   .CYCLES    SET	2
      2  1c21
      3  1c21				  -	      IF	.CYCLES < 2
      4  1c21				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c21				  -	      ERR
      6  1c21					      ENDIF
      7  1c21
      8  1c21				  -	      IF	.CYCLES & 1
      9  1c21				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c21				  -	      nop	0
     11  1c21				  -	      ELSE
     12  1c21				  -	      bit	VSYNC
     13  1c21				  -	      ENDIF
     14  1c21				  -.CYCLES    SET	.CYCLES - 3
     15  1c21					      ENDIF
     16  1c21
     17  1c21					      REPEAT	.CYCLES / 2
     18  1c21		       ea		      nop
     19  1c22					      REPEND
    738  1c22		       4c 85 1a 	      jmp	loop3	; 31
    739  1c25
    740  1c25				   kernel7
    741  1c25		       a9 12		      lda	#<DF2DATAW
    742  1c27		       85 1b		      STA	GRP0	; 25 (VDEL)
    743  1c29		       a9 23		      lda	#<DF3FLAG
    744  1c2b		       85 1f		      STA	ENABL	; 30 (VDEL)
    745  1c2d		       a9 19		      lda	#<DF1FRACDATA
    746  1c2f		       85 0f		      STA	PF2	; 35
    747  1c31		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    748  1c33		       85 05		      STA	NUSIZ1	; 40
    749  1c35		       85 0c		      STA	REFP1	; 43
    750  1c37		       a9 1a		      lda	#<DF2FRACDATA	;45
    751  1c39		       85 0f		      sta	PF2	; 48
      0  1c3b					      sleep	2
      1  1c3b				   .CYCLES    SET	2
      2  1c3b
      3  1c3b				  -	      IF	.CYCLES < 2
      4  1c3b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c3b				  -	      ERR
      6  1c3b					      ENDIF
      7  1c3b
      8  1c3b				  -	      IF	.CYCLES & 1
      9  1c3b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c3b				  -	      nop	0
     11  1c3b				  -	      ELSE
     12  1c3b				  -	      bit	VSYNC
     13  1c3b				  -	      ENDIF
     14  1c3b				  -.CYCLES    SET	.CYCLES - 3
     15  1c3b					      ENDIF
     16  1c3b
     17  1c3b					      REPEAT	.CYCLES / 2
     18  1c3b		       ea		      nop
     19  1c3c					      REPEND
    753  1c3c		       85 11		      sta	RESP1	;53
    754  1c3e		       a9 1b		      lda	#<DF3FRACDATA	;55
    755  1c40		       85 0e		      sta	PF1	; 58
      0  1c42					      sleep	3
      1  1c42				   .CYCLES    SET	3
      2  1c42
      3  1c42				  -	      IF	.CYCLES < 2
      4  1c42				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c42				  -	      ERR
      6  1c42					      ENDIF
      7  1c42
      8  1c42					      IF	.CYCLES & 1
      9  1c42					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c42		       04 00		      nop	0
     11  1c44				  -	      ELSE
     12  1c44				  -	      bit	VSYNC
     13  1c44					      ENDIF
     14  1c44				   .CYCLES    SET	.CYCLES - 3
     15  1c44					      ENDIF
     16  1c44
     17  1c44				  -	      REPEAT	.CYCLES / 2
     18  1c44				  -	      nop
     19  1c44					      REPEND
    757  1c44		       4c db 1a 	      JMP	getbackearly	; 64
    758  1c47
    759  1c47				   kernel8
    760  1c47		       a9 12		      lda	#<DF2DATAW
    761  1c49		       85 1b		      STA	GRP0	; (VDEL)
    762  1c4b		       a9 23		      lda	#<DF3FLAG
    763  1c4d		       85 1f		      STA	ENABL	; (VDEL)
    764  1c4f		       a9 19		      lda	#<DF1FRACDATA
    765  1c51		       85 0f		      STA	PF2	; 35
    766  1c53		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    767  1c55		       85 05		      STA	NUSIZ1	; 40
    768  1c57		       85 0c		      STA	REFP1	; 43
    769  1c59		       a9 1a		      lda	#<DF2FRACDATA	;45
    770  1c5b		       85 0f		      sta	PF2	; 48
    771  1c5d		       a9 1b		      lda	#<DF3FRACDATA	;50
    772  1c5f		       85 0e		      sta	PF1	; 53
      0  1c61					      sleep	2
      1  1c61				   .CYCLES    SET	2
      2  1c61
      3  1c61				  -	      IF	.CYCLES < 2
      4  1c61				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c61				  -	      ERR
      6  1c61					      ENDIF
      7  1c61
      8  1c61				  -	      IF	.CYCLES & 1
      9  1c61				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c61				  -	      nop	0
     11  1c61				  -	      ELSE
     12  1c61				  -	      bit	VSYNC
     13  1c61				  -	      ENDIF
     14  1c61				  -.CYCLES    SET	.CYCLES - 3
     15  1c61					      ENDIF
     16  1c61
     17  1c61					      REPEAT	.CYCLES / 2
     18  1c61		       ea		      nop
     19  1c62					      REPEND
    774  1c62		       85 11		      sta	RESP1	;58
      0  1c64					      sleep	3
      1  1c64				   .CYCLES    SET	3
      2  1c64
      3  1c64				  -	      IF	.CYCLES < 2
      4  1c64				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c64				  -	      ERR
      6  1c64					      ENDIF
      7  1c64
      8  1c64					      IF	.CYCLES & 1
      9  1c64					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c64		       04 00		      nop	0
     11  1c66				  -	      ELSE
     12  1c66				  -	      bit	VSYNC
     13  1c66					      ENDIF
     14  1c66				   .CYCLES    SET	.CYCLES - 3
     15  1c66					      ENDIF
     16  1c66
     17  1c66				  -	      REPEAT	.CYCLES / 2
     18  1c66				  -	      nop
     19  1c66					      REPEND
    776  1c66		       4c db 1a 	      JMP	getbackearly	; 64
    777  1c69
    778  1c69				   kernel9
    779  1c69		       a9 12		      lda	#<DF2DATAW
    780  1c6b		       85 1b		      STA	GRP0	; (VDEL)
    781  1c6d		       a9 23		      lda	#<DF3FLAG
    782  1c6f		       85 1f		      STA	ENABL	; (VDEL)
    783  1c71		       a9 19		      lda	#<DF1FRACDATA
    784  1c73		       85 0f		      STA	PF2	; 35
    785  1c75		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    786  1c77		       85 05		      STA	NUSIZ1	; 40
    787  1c79		       85 0c		      STA	REFP1	; 43
    788  1c7b		       a9 1a		      lda	#<DF2FRACDATA	;45
    789  1c7d		       85 0f		      sta	PF2	; 48
    790  1c7f		       a9 1b		      lda	#<DF3FRACDATA	;50
    791  1c81		       85 0e		      sta	PF1	; 53
      0  1c83					      sleep	5
      1  1c83				   .CYCLES    SET	5
      2  1c83
      3  1c83				  -	      IF	.CYCLES < 2
      4  1c83				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c83				  -	      ERR
      6  1c83					      ENDIF
      7  1c83
      8  1c83					      IF	.CYCLES & 1
      9  1c83					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c83		       04 00		      nop	0
     11  1c85				  -	      ELSE
     12  1c85				  -	      bit	VSYNC
     13  1c85					      ENDIF
     14  1c85				   .CYCLES    SET	.CYCLES - 3
     15  1c85					      ENDIF
     16  1c85
     17  1c85					      REPEAT	.CYCLES / 2
     18  1c85		       ea		      nop
     19  1c86					      REPEND
    793  1c86		       a9 18		      lda	#<DF0FRACDATA
    794  1c88		       85 11		      sta	RESP1	;63
      0  1c8a					      sleep	3
      1  1c8a				   .CYCLES    SET	3
      2  1c8a
      3  1c8a				  -	      IF	.CYCLES < 2
      4  1c8a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c8a				  -	      ERR
      6  1c8a					      ENDIF
      7  1c8a
      8  1c8a					      IF	.CYCLES & 1
      9  1c8a					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c8a		       04 00		      nop	0
     11  1c8c				  -	      ELSE
     12  1c8c				  -	      bit	VSYNC
     13  1c8c					      ENDIF
     14  1c8c				   .CYCLES    SET	.CYCLES - 3
     15  1c8c					      ENDIF
     16  1c8c
     17  1c8c				  -	      REPEAT	.CYCLES / 2
     18  1c8c				  -	      nop
     19  1c8c					      REPEND
    796  1c8c		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    797  1c8e		       4c 69 1a 	      jmp	loop	;72
    798  1c91
    799  1c91				   kernel10
    800  1c91		       a9 12		      lda	#<DF2DATAW
    801  1c93		       85 1b		      STA	GRP0	; 25 (VDEL)
    802  1c95		       a9 23		      lda	#<DF3FLAG
    803  1c97		       85 1f		      STA	ENABL	; 30 (VDEL)
    804  1c99		       a9 19		      lda	#<DF1FRACDATA
    805  1c9b		       85 0f		      STA	PF2	; 35
    806  1c9d		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    807  1c9f		       85 05		      STA	NUSIZ1	; 40
    808  1ca1		       85 0c		      STA	REFP1	; 43
    809  1ca3		       a9 1a		      lda	#<DF2FRACDATA	;45
    810  1ca5		       85 0f		      sta	PF2	; 48
    811  1ca7		       a9 1b		      lda	#<DF3FRACDATA	;50
    812  1ca9		       85 0e		      sta	PF1	; 53
      0  1cab					      sleep	6
      1  1cab				   .CYCLES    SET	6
      2  1cab
      3  1cab				  -	      IF	.CYCLES < 2
      4  1cab				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1cab				  -	      ERR
      6  1cab					      ENDIF
      7  1cab
      8  1cab				  -	      IF	.CYCLES & 1
      9  1cab				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1cab				  -	      nop	0
     11  1cab				  -	      ELSE
     12  1cab				  -	      bit	VSYNC
     13  1cab				  -	      ENDIF
     14  1cab				  -.CYCLES    SET	.CYCLES - 3
     15  1cab					      ENDIF
     16  1cab
     17  1cab					      REPEAT	.CYCLES / 2
     18  1cab		       ea		      nop
     17  1cab					      REPEND
     18  1cac		       ea		      nop
     17  1cac					      REPEND
     18  1cad		       ea		      nop
     19  1cae					      REPEND
    814  1cae		       a9 18		      lda	#<DF0FRACDATA
    815  1cb0		       ae 08 10 	      LDX	DF0DATA	; 65
    816  1cb3		       85 11		      sta	RESP1	; 68
    817  1cb5		       85 0e		      STA	PF1	; 71
    818  1cb7		       a9 09		      lda	#<DF1DATA	; 74
    819  1cb9		       86 06		      STX	COLUP0	; 0
    820  1cbb		       4c 6f 1a 	      jmp	loop2	; 3
    821  1cbe
    822  1cbe				   kernel11
    823  1cbe		       a9 12		      lda	#<DF2DATAW
    824  1cc0		       85 1b		      STA	GRP0	; (VDEL)
    825  1cc2		       a9 23		      lda	#<DF3FLAG
    826  1cc4		       85 1f		      STA	ENABL	; (VDEL)
    827  1cc6		       a9 19		      lda	#<DF1FRACDATA
    828  1cc8		       85 0f		      STA	PF2	; 35
    829  1cca		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    830  1ccc		       85 05		      STA	NUSIZ1
    831  1cce		       85 0c		      STA	REFP1
    832  1cd0		       a9 1a		      lda	#<DF2FRACDATA	;45
    833  1cd2		       85 0f		      sta	PF2	; 48
    834  1cd4		       a9 1b		      lda	#<DF3FRACDATA	;50
    835  1cd6		       85 0e		      sta	PF1	; 53
      0  1cd8					      sleep	3
      1  1cd8				   .CYCLES    SET	3
      2  1cd8
      3  1cd8				  -	      IF	.CYCLES < 2
      4  1cd8				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1cd8				  -	      ERR
      6  1cd8					      ENDIF
      7  1cd8
      8  1cd8					      IF	.CYCLES & 1
      9  1cd8					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1cd8		       04 00		      nop	0
     11  1cda				  -	      ELSE
     12  1cda				  -	      bit	VSYNC
     13  1cda					      ENDIF
     14  1cda				   .CYCLES    SET	.CYCLES - 3
     15  1cda					      ENDIF
     16  1cda
     17  1cda				  -	      REPEAT	.CYCLES / 2
     18  1cda				  -	      nop
     19  1cda					      REPEND
    837  1cda		       a9 19		      lda	#<DF1FRACDATA	;45
    838  1cdc		       85 0f		      sta	PF2	; 61
    839  1cde		       ae 08 10 	      LDX	DF0DATA	; 65
    840  1ce1
    841  1ce1		       a9 18		      lda	#<DF0FRACDATA	; 67
    842  1ce3		       85 0e		      sta	PF1	; 70
    843  1ce5		       85 11		      sta	RESP1	; 73
    844  1ce7		       86 06		      STX	COLUP0	; 0
    845  1ce9		       a9 09		      lda	#<DF1DATA	; 2
    846  1ceb		       85 07		      sta	COLUP1	; 5
    847  1ced		       a9 0b		      lda	#<DF3DATA
    848  1cef		       85 1c		      STA	GRP1	; 10
    849  1cf1		       a9 20		      lda	#<DF0FLAG
    850  1cf3		       85 1d		      STA	ENAM0	; 25
    851  1cf5		       a9 1e		      lda	#<DF6FRACDATA
    852  1cf7		       85 09		      STA	COLUBK	; 20
    853  1cf9		       a9 1c		      lda	#<DF4FRACDATA
    854  1cfb		       85 08		      sta	COLUPF	; 25
      0  1cfd					      sleep	3
      1  1cfd				   .CYCLES    SET	3
      2  1cfd
      3  1cfd				  -	      IF	.CYCLES < 2
      4  1cfd				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1cfd				  -	      ERR
      6  1cfd					      ENDIF
      7  1cfd
      8  1cfd					      IF	.CYCLES & 1
      9  1cfd					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1cfd		       04 00		      nop	0
     11  1cff				  -	      ELSE
     12  1cff				  -	      bit	VSYNC
     13  1cff					      ENDIF
     14  1cff				   .CYCLES    SET	.CYCLES - 3
     15  1cff					      ENDIF
     16  1cff
     17  1cff				  -	      REPEAT	.CYCLES / 2
     18  1cff				  -	      nop
     19  1cff					      REPEND
    856  1cff		       4c 85 1a 	      jmp	loop3	; 31
    857  1d02
    858  1d02				   set_fetchers
    859  1d02		       ad 6d 1d 	      lda	dflow
    860  1d05		       8d 50 10 	      sta	DF0LOW
    861  1d08		       ad 75 1d 	      lda	dfhigh
    862  1d0b		       8d 68 10 	      sta	DF0HI
    863  1d0e
    864  1d0e		       ad 6e 1d 	      lda	dflow+1
    865  1d11		       8d 51 10 	      sta	DF1LOW
    866  1d14		       ad 76 1d 	      lda	dfhigh+1
    867  1d17		       8d 69 10 	      sta	DF1HI
    868  1d1a
    869  1d1a		       ad 6f 1d 	      lda	dflow+2
    870  1d1d		       8d 52 10 	      sta	DF2LOW
    871  1d20		       ad 77 1d 	      lda	dfhigh+2
    872  1d23		       8d 6a 10 	      sta	DF2HI
    873  1d26
    874  1d26				   set_fetchers36		; sets just 3-6
    875  1d26		       ad 70 1d 	      lda	dflow+3
    876  1d29		       8d 53 10 	      sta	DF3LOW
    877  1d2c		       ad 78 1d 	      lda	dfhigh+3
    878  1d2f		       8d 6b 10 	      sta	DF3HI
    879  1d32
    880  1d32		       ad 71 1d 	      lda	dflow+4
    881  1d35		       8d 54 10 	      sta	DF4LOW
    882  1d38		       ad 79 1d 	      lda	dfhigh+4
    883  1d3b		       8d 6c 10 	      sta	DF4HI
    884  1d3e
    885  1d3e		       ad 72 1d 	      lda	dflow+5
    886  1d41		       8d 55 10 	      sta	DF5LOW
    887  1d44		       ad 7a 1d 	      lda	dfhigh+5
    888  1d47		       8d 6d 10 	      sta	DF5HI
    889  1d4a
    890  1d4a		       ad 73 1d 	      lda	dflow+6
    891  1d4d		       8d 56 10 	      sta	DF6LOW
    892  1d50		       ad 7b 1d 	      lda	dfhigh+6
    893  1d53		       8d 6e 10 	      sta	DF6HI
    894  1d56
    895  1d56		       60		      rts
    896  1d57
    897  1d57							;9d bad
    898  1d57							; the below isn't quite right
    899  1d57							;DF0DATA: COLUP0
    900  1d57							;DF1DATA: COLUP1
    901  1d57							;DF2DATAW: GRP0
    902  1d57							;DF3DATA: GRP1 
    903  1d57							;DF4DATA: 2lk lines until repos/HMP1
    904  1d57							;DF5DATA: low byte of repo kernels (xpos mod 15)
    905  1d57							;DF6DATA: High byte of repo kernels (x pos div 15)
    906  1d57							;DF7DATA: Programmer's stack
    907  1d57							;DF0FRACDATA: PF1L
    908  1d57							;DF1FRACDATA: PF2L
    909  1d57							;DF4FRACDATA: COLUPF
    910  1d57							;DF2FRACDATA: PF2R
    911  1d57							;DF3FRACDATA: PF2L
    912  1d57							;DF5FRACDATA: Sprite NUSIZ1/REFP1 (only during repos)
    913  1d57							;DF6FRACDATA: COLUBK
    914  1d57							;DF7FRACDATA: HMP1
    915  1d57							;DF3FLAG: kernel exit loop ?? (use flags instead?)
    916  1d57							;DF0FLAG: ENAM0
    917  1d57							;DF1FLAG: ENAM1 
    918  1d57							;DF3FLAG: ENABL 
    919  1d57
    920  1d57				   fetcher_address_table
    921  1d57				   kernello
    922  1d57		       37		      .byte.b	<kernel1
    923  1d58		       59		      .byte.b	<kernel2
    924  1d59		       7b		      .byte.b	<kernel3
    925  1d5a		       9d		      .byte.b	<kernel4
    926  1d5b		       bf		      .byte.b	<kernel5
    927  1d5c		       e1		      .byte.b	<kernel6
    928  1d5d		       25		      .byte.b	<kernel7
    929  1d5e		       47		      .byte.b	<kernel8
    930  1d5f		       69		      .byte.b	<kernel9
    931  1d60		       91		      .byte.b	<kernel10
    932  1d61		       be		      .byte.b	<kernel11
    933  1d62				   kernelhi
    934  1d62		       1b		      .byte.b	>kernel1
    935  1d63		       1b		      .byte.b	>kernel2
    936  1d64		       1b		      .byte.b	>kernel3
    937  1d65		       1b		      .byte.b	>kernel4
    938  1d66		       1b		      .byte.b	>kernel5
    939  1d67		       1b		      .byte.b	>kernel6
    940  1d68		       1c		      .byte.b	>kernel7
    941  1d69		       1c		      .byte.b	>kernel8
    942  1d6a		       1c		      .byte.b	>kernel9
    943  1d6b		       1c		      .byte.b	>kernel10
    944  1d6c		       1c		      .byte.b	>kernel11
    945  1d6d				   dflow
    946  1d6d		       08		      .byte.b	<P0COLOR
    947  1d6e		       08		      .byte.b	<P1COLOR
    948  1d6f		       08		      .byte.b	<P0GFX
    949  1d70		       08		      .byte.b	<P1GFX
    950  1d71		       2d		      .byte.b	<P1SKIP
    951  1d72		       08		      .byte.b	<JUMPTABLELO
    952  1d73		       14		      .byte.b	<JUMPTABLEHI
    953  1d74		       a5		      .byte.b	<USERSTACK
    954  1d75				   dfhigh
    955  1d75		       05		      .byte.b	(>P0COLOR) & $0F
    956  1d76		       03		      .byte.b	(>P1COLOR) & $0F
    957  1d77		       04		      .byte.b	(>P0GFX) & $0F
    958  1d78		       02		      .byte.b	(>P1GFX) & $0F
    959  1d79		       0b		      .byte.b	(>P1SKIP) & $0F
    960  1d7a		       0b		      .byte.b	(>JUMPTABLELO) & $0F
    961  1d7b		       0b		      .byte.b	(>JUMPTABLEHI) & $0F
    962  1d7c		       0d		      .byte.b	(>USERSTACK) & $0F
    963  1d7d				   dffraclow
    964  1d7d		       08		      .byte.b	<PF1L
    965  1d7e		       08		      .byte.b	<PF2L
    966  1d7f		       08		      .byte.b	<PF1R
    967  1d80		       08		      .byte.b	<PF2R
    968  1d81		       08		      .byte.b	<PFCOLS
    969  1d82		       39		      .byte.b	<NUSIZREFP
    970  1d83		       a5		      .byte.b	<BKCOLS
    971  1d84		       20		      .byte.b	<P1HMP
    972  1d85				   dffrachi
    973  1d85		       06		      .byte.b	(>PF1L) & $0F
    974  1d86		       07		      .byte.b	(>PF2L) & $0F
    975  1d87		       08		      .byte.b	(>PF1R) & $0F
    976  1d88		       09		      .byte.b	(>PF2R) & $0F
    977  1d89		       0a		      .byte.b	(>PFCOLS) & $0F
    978  1d8a		       0b		      .byte.b	(>NUSIZREFP) & $0F
    979  1d8b		       0b		      .byte.b	(>BKCOLS) & $0F
    980  1d8c		       0b		      .byte.b	(>P1HMP) & $0F
    981  1d8d				   scorepointer
    982  1d8d		       94		      .byte.b	<scoretable
    983  1d8e		       08		      .byte.b	((>scoretable) & $0f) | (((>scoretable) / 2) & $70)
    984  1d8f				   scoresetup		; pointers to digit graphics
    985  1d8f		       45		      .byte.b	<scoredata
    986  1d90		       0b		      .byte.b	(>scoredata) & $0F
    987  1d91				   Hmval		; 112 wuz first
    988  1d91		       60 50 40 30*	      .byte.b	96, 80, 64, 48, 32, 16, 1, 240
    989  1d99				   Hmval74
    990  1d99		       e0 d0 c0 b0*	      .byte.b	224, 208, 192, 176, 160, 144, 128
    991  1da0		       60 50 40 30*	      .byte.b	96, 80, 64, 48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96
    992  1db0		       50 40 30 20*	      .byte.b	80, 64, 48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80
    993  1dc0		       40 30 20 10*	      .byte.b	64, 48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64
    994  1dd0		       30 20 10 01*	      .byte.b	48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48
    995  1de0		       20 10 01 f0*	      .byte.b	32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32
    996  1df0		       10 01 f0 e0*	      .byte.b	16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16
    997  1e00		       01 f0 e0 d0*	      .byte.b	1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16, 1
    998  1e10		       f0 e0 d0 c0*	      .byte.b	240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16, 1, 240
    999  1e20		       e0 d0 c0 b0*	      .byte.b	224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16, 1, 240, 224, 208, 192
   1000  1e32		       b0 a0 90 80*	      .byte.b	176,160,144,128,16,1,240,224
   1001  1e3a
   1002  1e3a
   1003  1e3a				   kernel_setup
   1004  1e3a							;--position P0, top P1, M0, M1, BL
   1005  1e3a		       a2 00		      ldx	#0	; first sprite displayed
   1006  1e3c		       b5 85		      lda	SpriteGfxIndex,x
   1007  1e3e		       aa		      tax
   1008  1e3f		       b5 90		      lda	player1x,x
   1009  1e41		       c9 a0		      cmp	#160
   1010  1e43		       90 0a		      bcc	nostorep1
   1011  1e45		       c9 d0		      cmp	#208
   1012  1e47		       b0 02		      bcs	ksadjustdown
   1013  1e49							; 160-208: minus 160
   1014  1e49							;add 160 is like minus 96
   1015  1e49							; so minus 64
   1016  1e49		       e9 3f		      sbc	#63	;cc
   1017  1e4b				   ksadjustdown
   1018  1e4b							; 209-255: add 160 
   1019  1e4b		       69 9f		      adc	#159	; cs
   1020  1e4d		       95 90		      sta	player1x,x
   1021  1e4f				   nostorep1
   1022  1e4f		       85 02		      sta	WSYNC
   1023  1e51		       a2 04		      ldx	#4
   1024  1e53		       85 81		      sta	topP1x	; cache top p1
   1025  1e55				   HorPosLoop
   1026  1e55		       b5 80		      lda	player0x,X
   1027  1e57		       38		      sec
   1028  1e58				   DivideLoop
   1029  1e58		       e9 0f		      sbc	#15
   1030  1e5a		       b0 fc		      bcs	DivideLoop
      0  1e5c					      sleep	4
      1  1e5c				   .CYCLES    SET	4
      2  1e5c
      3  1e5c				  -	      IF	.CYCLES < 2
      4  1e5c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1e5c				  -	      ERR
      6  1e5c					      ENDIF
      7  1e5c
      8  1e5c				  -	      IF	.CYCLES & 1
      9  1e5c				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1e5c				  -	      nop	0
     11  1e5c				  -	      ELSE
     12  1e5c				  -	      bit	VSYNC
     13  1e5c				  -	      ENDIF
     14  1e5c				  -.CYCLES    SET	.CYCLES - 3
     15  1e5c					      ENDIF
     16  1e5c
     17  1e5c					      REPEAT	.CYCLES / 2
     18  1e5c		       ea		      nop
     17  1e5c					      REPEND
     18  1e5d		       ea		      nop
     19  1e5e					      REPEND
   1032  1e5e		       95 10		      sta	RESP0,X
   1033  1e60		       85 02		      sta	WSYNC
   1034  1e62		       ca		      dex		;2
   1035  1e63		       10 f0		      bpl	HorPosLoop	;4/5
   1036  1e65
   1037  1e65		       a4 80		      ldy	player0x	; 7
   1038  1e67		       b9 91 1d 	      lda	Hmval,y	; 11
   1039  1e6a		       85 20		      sta	HMP0	; 14
   1040  1e6c
   1041  1e6c		       a4 81		      ldy	player0x+1
   1042  1e6e		       b9 91 1d 	      lda	Hmval,y
   1043  1e71		       85 21		      sta	HMP0+1	; 24
   1044  1e73
   1045  1e73		       a4 82		      ldy	player0x+2
   1046  1e75		       b9 91 1d 	      lda	Hmval,y
   1047  1e78		       85 22		      sta	HMP0+2	; 34
   1048  1e7a
   1049  1e7a		       a4 83		      ldy	player0x+3
   1050  1e7c		       b9 91 1d 	      lda	Hmval,y
   1051  1e7f		       85 23		      sta	HMP0+3	; 44
   1052  1e81
   1053  1e81		       a4 84		      ldy	player0x+4
   1054  1e83		       b9 91 1d 	      lda	Hmval,y
   1055  1e86		       85 24		      sta	HMP0+4	; 54
   1056  1e88
   1057  1e88		       85 02		      sta	WSYNC
   1058  1e8a		       85 2a		      sta	HMOVE
   1059  1e8c
   1060  1e8c				   myrts
   1061  1e8c		       60		      rts
   1062  1e8d
   1063  1e8d
   1064  1e8d				   pfsetup
   1065  1e8d
   1066  1e8d		       84 cb		      sty	temp1
   1067  1e8f		       85 cc		      sta	temp2
   1068  1e91		       86 cd		      stx	temp3
   1069  1e93		       a2 03		      ldx	#3
   1070  1e95				   pfsetupp
   1071  1e95		       bd 7d 1d 	      lda	dffraclow,x
   1072  1e98		       9d 50 10 	      sta	DF0LOW,x
   1073  1e9b		       bd 85 1d 	      lda	dffrachi,x
   1074  1e9e		       9d 68 10 	      sta	DF0HI,x
   1075  1ea1		       a5 cc		      lda	temp2
   1076  1ea3		       8d 59 10 	      sta	PARAMETER
   1077  1ea6		       a5 cd		      lda	temp3
   1078  1ea8		       8d 59 10 	      sta	PARAMETER
   1079  1eab		       8e 59 10 	      stx	PARAMETER
   1080  1eae		       8c 59 10 	      sty	PARAMETER
   1081  1eb1		       a9 01		      LDA	#1
   1082  1eb3		       8d 5a 10 	      sta	CALLFUNCTION
   1083  1eb6		       18		      clc
   1084  1eb7		       a5 cc		      lda	temp2
   1085  1eb9		       65 cb		      adc	temp1
   1086  1ebb		       85 cc		      sta	temp2
   1087  1ebd		       a5 cd		      lda	temp3
   1088  1ebf		       69 00		      adc	#0
   1089  1ec1		       85 cd		      sta	temp3
   1090  1ec3		       ca		      dex
   1091  1ec4		       10 cf		      bpl	pfsetupp
      0  1ec6					      RETURN
      1  1ec6				  -	      ifnconst	bankswitch
      2  1ec6				  -	      rts
      3  1ec6					      else
      4  1ec6		       4c e0 df 	      jmp	BS_return
      5  1ec9					      endif
   1093  1ec9
   1094  1ec9
   1095  1ec9				   scorekernel
   1096  1ec9				  -	      ifconst	minikernel
   1097  1ec9				  -			;; disable fast fetch, call the minikernel, and re-enable fast fetch
   1098  1ec9				  -	      lda	#255
   1099  1ec9				  -	      sta	FASTFETCH
   1100  1ec9				  -	      jsr	minikernel
   1101  1ec9				  -	      lda	#0
   1102  1ec9				  -	      sta.w	FASTFETCH
   1103  1ec9					      endif
   1104  1ec9		       a6 eb		      ldx	scorecolor
   1105  1ecb		       86 06		      stx	COLUP0
   1106  1ecd		       86 07		      stx	COLUP1
   1107  1ecf		       a2 00		      ldx	#0
   1108  1ed1		       86 0e		      STx	PF1
   1109  1ed3		       86 0b		      stx	REFP0
   1110  1ed5		       86 0c		      stx	REFP1
   1111  1ed7		       86 1b		      STx	GRP0
   1112  1ed9		       86 1c		      STx	GRP1
   1113  1edb		       86 0f		      STx	PF2
   1114  1edd		       86 2b		      stx	HMCLR
   1115  1edf		       86 1d		      stx	ENAM0
   1116  1ee1		       86 1e		      stx	ENAM1
   1117  1ee3		       86 1f		      stx	ENABL
   1118  1ee5
   1119  1ee5
   1120  1ee5				  -	      ifconst	pfscore
   1121  1ee5				  -	      lda	pfscorecolor
   1122  1ee5				  -	      sta	COLUPF
   1123  1ee5					      endif
   1124  1ee5
   1125  1ee5				  -	      ifconst	noscore
   1126  1ee5				  -	      ldx	#10
   1127  1ee5				  -noscoreloop
   1128  1ee5				  -	      sta	WSYNC
   1129  1ee5				  -	      dex
   1130  1ee5				  -	      bpl	noscoreloop
   1131  1ee5				  -	      rts
   1132  1ee5					      else
   1133  1ee5
   1134  1ee5		       85 2b		      sta	HMCLR
   1135  1ee7		       a2 f0		      ldx	#$f0
   1136  1ee9		       86 20		      stx	HMP0
   1137  1eeb
   1138  1eeb							; set up fetchers 0-5 to handle score digits
   1139  1eeb		       a2 45		      ldx	#<(scoredata)
   1140  1eed		       8e 56 10 	      stx	DF6LOW
   1141  1ef0		       a2 0b		      ldx	#(>(scoredata)) & $0F
   1142  1ef2		       8e 6e 10 	      stx	DF6HI
   1143  1ef5		       a2 4d		      ldx	#<(scoredata+8)
   1144  1ef7		       8e 50 10 	      stx	DF0LOW
   1145  1efa		       a2 0b		      ldx	#(>(scoredata+8)) & $0F
   1146  1efc		       8e 68 10 	      stx	DF0HI
   1147  1eff		       a2 55		      ldx	#<(scoredata+16)
   1148  1f01		       8e 51 10 	      stx	DF1LOW
   1149  1f04							; cycle 0??
   1150  1f04		       a2 0b		      ldx	#(>(scoredata+16)) & $0F
   1151  1f06		       8e 69 10 	      stx	DF1HI
   1152  1f09		       a2 5d		      ldx	#<(scoredata+24)
   1153  1f0b		       8e 52 10 	      stx	DF2LOW
   1154  1f0e		       a2 0b		      ldx	#(>(scoredata+24)) & $0F
   1155  1f10		       8e 6a 10 	      stx	DF2HI
   1156  1f13
   1157  1f13		       85 02		      sta	WSYNC
   1158  1f15		       a2 00		      ldx	#0
   1159  1f17		       86 1b		      STx	GRP0
   1160  1f19		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   1161  1f1b
   1162  1f1b		       a2 65		      ldx	#<(scoredata+32)
   1163  1f1d		       8e 53 10 	      stx	DF3LOW
   1164  1f20		       a2 0b		      ldx	#(>(scoredata+32)) & $0F
   1165  1f22		       8e 6b 10 	      stx	DF3HI
   1166  1f25		       a2 6d		      ldx	#<(scoredata+40)
   1167  1f27		       8e 54 10 	      stx	DF4LOW
   1168  1f2a		       a2 0b		      ldx	#(>(scoredata+40)) & $0F
   1169  1f2c		       8e 6c 10 	      stx	DF4HI
   1170  1f2f
   1171  1f2f		       a0 07		      LDY	#7
   1172  1f31		       a2 03		      LDx	#$03
   1173  1f33		       84 25		      STY	VDELP0
   1174  1f35		       85 10		      STA	RESP0
   1175  1f37		       85 11		      STA	RESP1
   1176  1f39		       84 cb		      sty	temp1
   1177  1f3b
   1178  1f3b		       86 04		      STx	NUSIZ0
   1179  1f3d		       86 05		      STx	NUSIZ1
   1180  1f3f		       86 26		      STx	VDELP1
   1181  1f41		       a2 75		      ldx	#<(scoredata+48)
   1182  1f43		       8e 55 10 	      stx	DF5LOW
   1183  1f46		       a2 0b		      ldx	#(>(scoredata+48)) & $0F
   1184  1f48		       8e 6d 10 	      stx	DF5HI
   1185  1f4b		       8d 2a 00 	      STA.w	HMOVE	; cycle 73 ?
   1186  1f4e				   scoreloop
   1187  1f4e		       a9 0e		      lda	#<DF6DATA	;59
   1188  1f50		       85 06		      sta	COLUP0	;62
   1189  1f52		       85 07		      sta	COLUP1	;65
   1190  1f54		       a9 09		      lda	#<DF1DATA	;75
   1191  1f56		       85 1b		      sta	GRP0	;2
   1192  1f58		       a9 08		      lda	#<DF0DATA	;4
   1193  1f5a		       85 1c		      sta	GRP1	;7
   1194  1f5c		       a9 0b		      lda	#<DF3DATA	;9
   1195  1f5e		       85 1b		      sta	GRP0	;12
   1196  1f60
   1197  1f60							; REVENG - rearranged to correct pf write timing and A register overwrite
   1198  1f60				  -	      ifconst	pfscore
   1199  1f60				  -	      lda	pfscore1
   1200  1f60				  -	      sta	PF1
   1201  1f60					      else
      0  1f60					      sleep	6
      1  1f60				   .CYCLES    SET	6
      2  1f60
      3  1f60				  -	      IF	.CYCLES < 2
      4  1f60				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f60				  -	      ERR
      6  1f60					      ENDIF
      7  1f60
      8  1f60				  -	      IF	.CYCLES & 1
      9  1f60				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f60				  -	      nop	0
     11  1f60				  -	      ELSE
     12  1f60				  -	      bit	VSYNC
     13  1f60				  -	      ENDIF
     14  1f60				  -.CYCLES    SET	.CYCLES - 3
     15  1f60					      ENDIF
     16  1f60
     17  1f60					      REPEAT	.CYCLES / 2
     18  1f60		       ea		      nop
     17  1f60					      REPEND
     18  1f61		       ea		      nop
     17  1f61					      REPEND
     18  1f62		       ea		      nop
     19  1f63					      REPEND
   1203  1f63					      endif
      0  1f63					      sleep	5
      1  1f63				   .CYCLES    SET	5
      2  1f63
      3  1f63				  -	      IF	.CYCLES < 2
      4  1f63				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f63				  -	      ERR
      6  1f63					      ENDIF
      7  1f63
      8  1f63					      IF	.CYCLES & 1
      9  1f63					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f63		       04 00		      nop	0
     11  1f65				  -	      ELSE
     12  1f65				  -	      bit	VSYNC
     13  1f65					      ENDIF
     14  1f65				   .CYCLES    SET	.CYCLES - 3
     15  1f65					      ENDIF
     16  1f65
     17  1f65					      REPEAT	.CYCLES / 2
     18  1f65		       ea		      nop
     19  1f66					      REPEND
   1205  1f66		       ae 0a 10 	      ldx	DF2DATA	;16
   1206  1f69		       ac 0d 10 	      ldy	DF5DATA	;20
   1207  1f6c		       a9 0c		      lda	#<DF4DATA	;22 
   1208  1f6e
   1209  1f6e		       86 1c		      stx	GRP1	;40
   1210  1f70		       84 1b		      sty	GRP0	;43
   1211  1f72		       85 1c		      sta	GRP1	;46
   1212  1f74		       85 1b		      sta	GRP0	;49
   1213  1f76				  -	      ifconst	pfscore
   1214  1f76				  -	      lda	pfscore2
   1215  1f76				  -	      sta	PF1
   1216  1f76					      else
      0  1f76					      sleep	6
      1  1f76				   .CYCLES    SET	6
      2  1f76
      3  1f76				  -	      IF	.CYCLES < 2
      4  1f76				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f76				  -	      ERR
      6  1f76					      ENDIF
      7  1f76
      8  1f76				  -	      IF	.CYCLES & 1
      9  1f76				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f76				  -	      nop	0
     11  1f76				  -	      ELSE
     12  1f76				  -	      bit	VSYNC
     13  1f76				  -	      ENDIF
     14  1f76				  -.CYCLES    SET	.CYCLES - 3
     15  1f76					      ENDIF
     16  1f76
     17  1f76					      REPEAT	.CYCLES / 2
     18  1f76		       ea		      nop
     17  1f76					      REPEND
     18  1f77		       ea		      nop
     17  1f77					      REPEND
     18  1f78		       ea		      nop
     19  1f79					      REPEND
   1218  1f79					      endif
   1219  1f79							; sleep 2 ;57
      0  1f79					      sleep	6
      1  1f79				   .CYCLES    SET	6
      2  1f79
      3  1f79				  -	      IF	.CYCLES < 2
      4  1f79				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f79				  -	      ERR
      6  1f79					      ENDIF
      7  1f79
      8  1f79				  -	      IF	.CYCLES & 1
      9  1f79				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f79				  -	      nop	0
     11  1f79				  -	      ELSE
     12  1f79				  -	      bit	VSYNC
     13  1f79				  -	      ENDIF
     14  1f79				  -.CYCLES    SET	.CYCLES - 3
     15  1f79					      ENDIF
     16  1f79
     17  1f79					      REPEAT	.CYCLES / 2
     18  1f79		       ea		      nop
     17  1f79					      REPEND
     18  1f7a		       ea		      nop
     17  1f7a					      REPEND
     18  1f7b		       ea		      nop
     19  1f7c					      REPEND
   1221  1f7c		       c6 cb		      dec	temp1	;70
   1222  1f7e		       10 ce		      bpl	scoreloop	;72/73
   1223  1f80		       a2 00		      LDx	#0
   1224  1f82		       86 0e		      stx	PF1
   1225  1f84		       86 1b		      STx	GRP0
   1226  1f86		       86 1c		      STx	GRP1
   1227  1f88		       86 25		      STx	VDELP0
   1228  1f8a		       86 26		      STx	VDELP1	;do we need these
   1229  1f8c		       86 04		      STx	NUSIZ0
   1230  1f8e		       86 05		      STx	NUSIZ1
   1231  1f90
   1232  1f90		       60		      rts
   1233  1f91
   1234  1f91
   1235  1f91					      endif		; noscore
   1236  1f91				   game
   1237  1f91				   .
   1238  1f91							; 
   1239  1f91
   1240  1f91				   .
   1241  1f91							; 
   1242  1f91
   1243  1f91				   .L00 		;  bank 1
   1244  1f91
   1245  1f91				   .L01 		;  temp1  =  temp1
   1246  1f91
   1247  1f91		       a5 cb		      LDA	temp1
   1248  1f93		       85 cb		      STA	temp1
   1249  1f95				   .
   1250  1f95							; 
   1251  1f95
   1252  1f95				   .
   1253  1f95							; 
   1254  1f95
   1255  1f95				   .L02 		;  set tv ntsc
   1256  1f95
   1257  1f95				   .
   1258  1f95							; 
   1259  1f95
   1260  1f95				   .
   1261  1f95							; 
   1262  1f95
   1263  1f95				   .L03 		;  set kernel DPC + 
   1264  1f95
   1265  1f95				   .L04 		;  set smartbranching on
   1266  1f95
   1267  1f95				   .L05 		;  set optimization inlinerand
   1268  1f95
   1269  1f95				   .L06 		;  set kernel_options collision(playfield,player1)
   1270  1f95
   1271  1f95		       00 43	   DPC_kernel_options =	CXP1FB+$40
   1272  1f95				   .
   1273  1f95							; 
   1274  1f95
   1275  1f95				   .
   1276  1f95							; 
   1277  1f95
   1278  1f95				   .
   1279  1f95							; 
   1280  1f95
   1281  1f95				   .
   1282  1f95							; 
   1283  1f95
   1284  1f95				   .L07 		;  player0x  =  77  :	player0y  =  150
   1285  1f95
   1286  1f95		       a9 4d		      LDA	#77
   1287  1f97		       85 80		      STA	player0x
   1288  1f99		       a9 96		      LDA	#150
   1289  1f9b		       85 99		      STA	player0y
   1290  1f9d				   .L08 		;  NUSIZ0  =  $03
   1291  1f9d
   1292  1f9d		       a9 03		      LDA	#$03
   1293  1f9f		       85 04		      STA	NUSIZ0
   1294  1fa1				   .
   1295  1fa1							; 
   1296  1fa1
   1297  1fa1				   .
   1298  1fa1							; 
   1299  1fa1
   1300  1fa1				   .L09 		;  player0:
   1301  1fa1
   1302  1fa1		       a2 a8		      LDX	#<playerL09_0
   1303  1fa3		       86 bd		      STX	player0pointerlo
   1304  1fa5		       a9 61		      LDA	#((>playerL09_0) & $0f) | (((>playerL09_0) / 2) & $70)
   1305  1fa7		       85 be		      STA	player0pointerhi
   1306  1fa9		       a9 08		      LDA	#8
   1307  1fab		       85 a5		      STA	player0height
   1308  1fad				   .
   1309  1fad							; 
   1310  1fad
   1311  1fad				   .
   1312  1fad							; 
   1313  1fad
   1314  1fad				   .L010		;  player0color:
   1315  1fad
   1316  1fad		       a2 b0		      LDX	#<playercolorL010_0
   1317  1faf		       86 a3		      STX	player0color
   1318  1fb1		       a9 61		      LDA	#((>playercolorL010_0) & $0f) | (((>playercolorL010_0) / 2) & $70)
   1319  1fb3		       85 a4		      STA	player0color+1
   1320  1fb5				   .
   1321  1fb5							; 
   1322  1fb5
   1323  1fb5				   .L011		;  goto __Start_Restart bank2
   1324  1fb5
   1325  1fb5		       85 81		      sta	temp7
   1326  1fb7		       a9 30		      lda	#>(.__Start_Restart-1)
   1327  1fb9		       48		      pha
   1328  1fba		       a9 a3		      lda	#<(.__Start_Restart-1)
   1329  1fbc		       48		      pha
   1330  1fbd		       a5 81		      lda	temp7
   1331  1fbf		       48		      pha
   1332  1fc0		       8a		      txa
   1333  1fc1		       48		      pha
   1334  1fc2		       a2 02		      ldx	#2
   1335  1fc4		       4c ee df 	      jmp	BS_jsr
   1336  1fc7				   .
   1337  1fc7							; 
   1338  1fc7
   1339  1fc7				   .
   1340  1fc7							; 
   1341  1fc7
   1342  1fc7				   .L012		;  bank 2
   1343  1fc7
   1344  1fc7					      if	ECHO1
      13 bytes of ROM space left in bank 1
   1345  1fc7					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
   1346  1fc7					      endif
   1347  1fc7		       00 01	   ECHO1      =	1
   1348  1fd4					      ORG	$1FF4-bscode_length
   1349  1fd4					      RORG	$1FF4-bscode_length
   1350  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   1351  1fd6					      ifconst	FASTFETCH	; using DPC+
   1352  1fd6		       8e 58 10 	      stx	FASTFETCH
   1353  1fd9					      endif
   1354  1fd9		       9a		      txs
   1355  1fda				  -	      if	bankswitch == 64
   1356  1fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1357  1fda					      else
   1358  1fda		       a9 18		      lda	#>(start-1)
   1359  1fdc					      endif
   1360  1fdc		       48		      pha
   1361  1fdd		       a9 e3		      lda	#<(start-1)
   1362  1fdf		       48		      pha
   1363  1fe0		       48		      pha
   1364  1fe1		       8a		      txa
   1365  1fe2		       48		      pha
   1366  1fe3		       ba		      tsx
   1367  1fe4					      if	bankswitch != 64
   1368  1fe4		       b5 04		      lda	4,x	; get high byte of return address
   1369  1fe6		       2a		      rol
   1370  1fe7		       2a		      rol
   1371  1fe8		       2a		      rol
   1372  1fe9		       2a		      rol
   1373  1fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1374  1fec		       aa		      tax
   1375  1fed		       e8		      inx
   1376  1fee				  -	      else
   1377  1fee				  -	      lda	4,x	; get high byte of return address
   1378  1fee				  -	      tay
   1379  1fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1380  1fee				  -	      sta	4,x
   1381  1fee				  -	      tya
   1382  1fee				  -	      lsr
   1383  1fee				  -	      lsr
   1384  1fee				  -	      lsr
   1385  1fee				  -	      lsr
   1386  1fee				  -	      tax
   1387  1fee				  -	      inx
   1388  1fee					      endif
   1389  1fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   1390  1ff1		       68		      pla
   1391  1ff2		       aa		      tax
   1392  1ff3		       68		      pla
   1393  1ff4		       60		      rts
   1394  1ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1395  1ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1396  1ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1397  1ff5					      endif
   1398  1ffc					      ORG	$1FFC
   1399  1ffc					      RORG	$1FFC
   1400  1ffc		       d4 1f		      .word.w	(start_bank1 & $ffff)
   1401  1ffe		       d4 1f		      .word.w	(start_bank1 & $ffff)
   1402  2000					      ORG	$2000
   1403  2000					      RORG	$3000
   1404  2000				   HMdiv
   1405  2000		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 0, 0
   1406  2007		       01 01 01 01*	      .byte.b	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2
   1407  2017		       02 02 02 02*	      .byte.b	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3
   1408  2027		       03 03 03 03*	      .byte.b	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4
   1409  2037		       04 04 04 04*	      .byte.b	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5
   1410  2047		       05 05 05 05*	      .byte.b	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6
   1411  2057		       06 06 06 06*	      .byte.b	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7
   1412  2067		       07 07 07 07*	      .byte.b	7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8
   1413  2077		       08 08 08 08*	      .byte.b	8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9
   1414  2087		       09 09 09 09*	      .byte.b	9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10
   1415  2097		       0a 0a 0a 0a*	      .byte.b	10,10,10,10,10,10,0,0,0
   1416  20a0				   .L013		;  temp1  =  temp1
   1417  20a0
   1418  20a0		       a5 cb		      LDA	temp1
   1419  20a2		       85 cb		      STA	temp1
   1420  20a4				   .
   1421  20a4							; 
   1422  20a4
   1423  20a4				   .__Start_Restart
   1424  20a4							; __Start_Restart
   1425  20a4
   1426  20a4				   .
   1427  20a4							; 
   1428  20a4
   1429  20a4				   .L014		;  gosub set_pf
   1430  20a4
   1431  20a4		       20 e0 30 	      jsr	.set_pf
   1432  20a7
   1433  20a7				   .
   1434  20a7							; 
   1435  20a7
   1436  20a7				   .__Main_Loop
   1437  20a7							; __Main_Loop
   1438  20a7
   1439  20a7				   .
   1440  20a7							; 
   1441  20a7
   1442  20a7				   .L015		;  DF0FRACINC	=  64
   1443  20a7
   1444  20a7		       a9 40		      LDA	#64
   1445  20a9		       8d 38 10 	      STA	DF0FRACINC
   1446  20ac				   .L016		;  DF1FRACINC	=  64
   1447  20ac
   1448  20ac		       a9 40		      LDA	#64
   1449  20ae		       8d 39 10 	      STA	DF1FRACINC
   1450  20b1				   .L017		;  DF2FRACINC	=  64
   1451  20b1
   1452  20b1		       a9 40		      LDA	#64
   1453  20b3		       8d 3a 10 	      STA	DF2FRACINC
   1454  20b6				   .L018		;  DF3FRACINC	=  64
   1455  20b6
   1456  20b6		       a9 40		      LDA	#64
   1457  20b8		       8d 3b 10 	      STA	DF3FRACINC
   1458  20bb				   .
   1459  20bb							; 
   1460  20bb
   1461  20bb				   .L019		;  DF4FRACINC	=  0
   1462  20bb
   1463  20bb		       a9 00		      LDA	#0
   1464  20bd		       8d 3c 10 	      STA	DF4FRACINC
   1465  20c0				   .L020		;  DF6FRACINC	=  0
   1466  20c0
   1467  20c0		       a9 00		      LDA	#0
   1468  20c2		       8d 3e 10 	      STA	DF6FRACINC
   1469  20c5				   .
   1470  20c5							; 
   1471  20c5
   1472  20c5				   .L021		;  drawscreen
   1473  20c5
   1474  20c5		       85 81		      sta	temp7
   1475  20c7		       a9 30		      lda	#>(ret_point1-1)
   1476  20c9		       48		      pha
   1477  20ca		       a9 dc		      lda	#<(ret_point1-1)
   1478  20cc		       48		      pha
   1479  20cd		       a9 19		      lda	#>(drawscreen-1)
   1480  20cf		       48		      pha
   1481  20d0		       a9 48		      lda	#<(drawscreen-1)
   1482  20d2		       48		      pha
   1483  20d3		       a5 81		      lda	temp7
   1484  20d5		       48		      pha
   1485  20d6		       8a		      txa
   1486  20d7		       48		      pha
   1487  20d8		       a2 01		      ldx	#1
   1488  20da		       4c ee df 	      jmp	BS_jsr
   1489  20dd				   ret_point1
   1490  20dd				   .
   1491  20dd							; 
   1492  20dd
   1493  20dd				   .L022		;  goto __Main_Loop
   1494  20dd
   1495  20dd		       4c a7 30 	      jmp	.__Main_Loop
   1496  20e0
   1497  20e0				   .
   1498  20e0							; 
   1499  20e0
   1500  20e0				   .set_pf
   1501  20e0							; set_pf
   1502  20e0
   1503  20e0				   .
   1504  20e0							; 
   1505  20e0
   1506  20e0				   .L023		;  pfcolors:
   1507  20e0
   1508  20e0		       a9 08		      LDA	#<PFCOLS
   1509  20e2		       8d 50 10 	      STA	DF0LOW
   1510  20e5		       a9 0a		      LDA	#(>PFCOLS) & $0F
   1511  20e7		       8d 68 10 	      STA	DF0HI
   1512  20ea		       a9 b8		      LDA	#<playfieldcolorL023
   1513  20ec		       8d 59 10 	      STA	PARAMETER
   1514  20ef		       a9 61		      LDA	#((>playfieldcolorL023) & $0f) | (((>playfieldcolorL023) / 2) & $70)
   1515  20f1		       8d 59 10 	      STA	PARAMETER
   1516  20f4		       a9 00		      LDA	#0
   1517  20f6		       8d 59 10 	      STA	PARAMETER
   1518  20f9		       a9 01		      LDA	#1
   1519  20fb		       8d 59 10 	      STA	PARAMETER
   1520  20fe		       a9 01		      LDA	#1
   1521  2100		       8d 5a 10 	      STA	CALLFUNCTION
   1522  2103				   .
   1523  2103							; 
   1524  2103
   1525  2103				   .L024		;  bkcolors:
   1526  2103
   1527  2103		       a9 a5		      LDA	#<BKCOLS
   1528  2105		       8d 50 10 	      STA	DF0LOW
   1529  2108		       a9 0b		      LDA	#(>BKCOLS) & $0F
   1530  210a		       8d 68 10 	      STA	DF0HI
   1531  210d		       a9 b9		      LDA	#<backgroundcolorL024
   1532  210f		       8d 59 10 	      STA	PARAMETER
   1533  2112		       a9 61		      LDA	#((>backgroundcolorL024) & $0f) | (((>backgroundcolorL024) / 2) & $70)
   1534  2114		       8d 59 10 	      STA	PARAMETER
   1535  2117		       a9 00		      LDA	#0
   1536  2119		       8d 59 10 	      STA	PARAMETER
   1537  211c		       a9 01		      LDA	#1
   1538  211e		       8d 59 10 	      STA	PARAMETER
   1539  2121		       a9 01		      LDA	#1
   1540  2123		       8d 5a 10 	      STA	CALLFUNCTION
   1541  2126				   .
   1542  2126							; 
   1543  2126
   1544  2126				   .L025		;  for temp1  =  0 to 31 step 2
   1545  2126
   1546  2126		       a9 00		      LDA	#0
   1547  2128		       85 cb		      STA	temp1
   1548  212a				   .L025fortemp1
   1549  212a				   .L026		;  temp2  =   ( rand & 31 )  + 10
   1550  212a
   1551  212a							; complex statement detected
   1552  212a		       ad 00 10 	      lda	rand
   1553  212d		       4a		      lsr
   1554  212e				  -	      ifconst	rand16
   1555  212e				  -	      rol	rand16
   1556  212e					      endif
   1557  212e		       90 02		      bcc	*+4
   1558  2130		       49 b4		      eor	#$B4
   1559  2132		       8d 00 10 	      sta	rand
   1560  2135				  -	      ifconst	rand16
   1561  2135				  -	      eor	rand16
   1562  2135					      endif
   1563  2135		       29 1f		      AND	#31
   1564  2137		       18		      CLC
   1565  2138		       69 0a		      ADC	#10
   1566  213a		       85 cc		      STA	temp2
   1567  213c				   .L027		;  temp3  =  temp1  +	1
   1568  213c
   1569  213c		       a5 cb		      LDA	temp1
   1570  213e		       18		      CLC
   1571  213f		       69 01		      ADC	#1
   1572  2141		       85 cd		      STA	temp3
   1573  2143				   .L028		;  pfvline temp1 temp2 43 on
   1574  2143
   1575  2143		       a9 a4		      lda	#<C_function
   1576  2145		       8d 50 10 	      sta	DF0LOW
   1577  2148		       a9 01		      lda	#(>C_function) & $0F
   1578  214a		       8d 68 10 	      sta	DF0HI
   1579  214d		       a2 04		      LDX	#4
   1580  214f		       8e 78 10 	      STX	DF0WRITE
   1581  2152		       a9 2b		      LDA	#43
   1582  2154		       8d 78 10 	      STA	DF0WRITE
   1583  2157		       a4 cc		      LDY	temp2
   1584  2159		       8c 78 10 	      STY	DF0WRITE
   1585  215c		       a5 cb		      LDA	temp1
   1586  215e		       8d 78 10 	      STA	DF0WRITE
   1587  2161		       a9 ff		      lda	#255
   1588  2163		       8d 5a 10 	      sta	CALLFUNCTION
   1589  2166				   .L029		;  pfvline temp3 temp2 43 on
   1590  2166
   1591  2166		       a9 a4		      lda	#<C_function
   1592  2168		       8d 50 10 	      sta	DF0LOW
   1593  216b		       a9 01		      lda	#(>C_function) & $0F
   1594  216d		       8d 68 10 	      sta	DF0HI
   1595  2170		       a2 04		      LDX	#4
   1596  2172		       8e 78 10 	      STX	DF0WRITE
   1597  2175		       a9 2b		      LDA	#43
   1598  2177		       8d 78 10 	      STA	DF0WRITE
   1599  217a		       a4 cc		      LDY	temp2
   1600  217c		       8c 78 10 	      STY	DF0WRITE
   1601  217f		       a5 cd		      LDA	temp3
   1602  2181		       8d 78 10 	      STA	DF0WRITE
   1603  2184		       a9 ff		      lda	#255
   1604  2186		       8d 5a 10 	      sta	CALLFUNCTION
   1605  2189				   .L030		;  next
   1606  2189
   1607  2189		       a5 cb		      LDA	temp1
   1608  218b		       18		      CLC
   1609  218c		       69 02		      ADC	#2
   1610  218e
   1611  218e		       85 cb		      STA	temp1
   1612  2190		       c9 20		      CMP	#31+1
   1613  2192					      if	((* - .L025fortemp1) < 127) && ((* - .L025fortemp1) > -128)
   1614  2192		       90 96		      bcc	.L025fortemp1
   1615  2194				  -	      else
   1616  2194				  -	      bcs	.0skipL025fortemp1
   1617  2194				  -	      jmp	.L025fortemp1
   1618  2194				  -.0skipL025fortemp1
   1619  2194					      endif
   1620  2194				   .
   1621  2194							; 
   1622  2194
   1623  2194				   .L031		;  return thisbank
   1624  2194
   1625  2194		       60		      RTS
   1626  2195				   .
   1627  2195							; 
   1628  2195
   1629  2195				   .
   1630  2195							; 
   1631  2195
   1632  2195				   .
   1633  2195							; 
   1634  2195
   1635  2195				   .
   1636  2195							; 
   1637  2195
   1638  2195				   .L032		;  bank 3
   1639  2195
   1640  2195					      if	ECHO2
      3647 bytes of ROM space left in bank 2
   1641  2195					      echo	"    ",[(start_bank2 - *)]d , "bytes of ROM space left in bank 2")
   1642  2195					      endif
   1643  2195		       00 01	   ECHO2      =	1
   1644  2fd4					      ORG	$2FF4-bscode_length
   1645  2fd4					      RORG	$3FF4-bscode_length
   1646  2fd4		       a2 ff	   start_bank2 ldx	#$ff
   1647  2fd6					      ifconst	FASTFETCH	; using DPC+
   1648  2fd6		       8e 58 10 	      stx	FASTFETCH
   1649  2fd9					      endif
   1650  2fd9		       9a		      txs
   1651  2fda				  -	      if	bankswitch == 64
   1652  2fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1653  2fda					      else
   1654  2fda		       a9 18		      lda	#>(start-1)
   1655  2fdc					      endif
   1656  2fdc		       48		      pha
   1657  2fdd		       a9 e3		      lda	#<(start-1)
   1658  2fdf		       48		      pha
   1659  2fe0		       48		      pha
   1660  2fe1		       8a		      txa
   1661  2fe2		       48		      pha
   1662  2fe3		       ba		      tsx
   1663  2fe4					      if	bankswitch != 64
   1664  2fe4		       b5 04		      lda	4,x	; get high byte of return address
   1665  2fe6		       2a		      rol
   1666  2fe7		       2a		      rol
   1667  2fe8		       2a		      rol
   1668  2fe9		       2a		      rol
   1669  2fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1670  2fec		       aa		      tax
   1671  2fed		       e8		      inx
   1672  2fee				  -	      else
   1673  2fee				  -	      lda	4,x	; get high byte of return address
   1674  2fee				  -	      tay
   1675  2fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1676  2fee				  -	      sta	4,x
   1677  2fee				  -	      tya
   1678  2fee				  -	      lsr
   1679  2fee				  -	      lsr
   1680  2fee				  -	      lsr
   1681  2fee				  -	      lsr
   1682  2fee				  -	      tax
   1683  2fee				  -	      inx
   1684  2fee					      endif
   1685  2fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   1686  2ff1		       68		      pla
   1687  2ff2		       aa		      tax
   1688  2ff3		       68		      pla
   1689  2ff4		       60		      rts
   1690  2ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1691  2ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1692  2ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1693  2ff5					      endif
   1694  2ffc					      ORG	$2FFC
   1695  2ffc					      RORG	$3FFC
   1696  2ffc		       d4 3f		      .word.w	(start_bank2 & $ffff)
   1697  2ffe		       d4 3f		      .word.w	(start_bank2 & $ffff)
   1698  3000					      ORG	$3000
   1699  3000					      RORG	$5000
   1700  3000					      repeat	129
   1701  3000		       00		      .byte.b	0
   1700  3000					      repend
   1701  3001		       00		      .byte.b	0
   1700  3001					      repend
   1701  3002		       00		      .byte.b	0
   1700  3002					      repend
   1701  3003		       00		      .byte.b	0
   1700  3003					      repend
   1701  3004		       00		      .byte.b	0
   1700  3004					      repend
   1701  3005		       00		      .byte.b	0
   1700  3005					      repend
   1701  3006		       00		      .byte.b	0
   1700  3006					      repend
   1701  3007		       00		      .byte.b	0
   1700  3007					      repend
   1701  3008		       00		      .byte.b	0
   1700  3008					      repend
   1701  3009		       00		      .byte.b	0
   1700  3009					      repend
   1701  300a		       00		      .byte.b	0
   1700  300a					      repend
   1701  300b		       00		      .byte.b	0
   1700  300b					      repend
   1701  300c		       00		      .byte.b	0
   1700  300c					      repend
   1701  300d		       00		      .byte.b	0
   1700  300d					      repend
   1701  300e		       00		      .byte.b	0
   1700  300e					      repend
   1701  300f		       00		      .byte.b	0
   1700  300f					      repend
   1701  3010		       00		      .byte.b	0
   1700  3010					      repend
   1701  3011		       00		      .byte.b	0
   1700  3011					      repend
   1701  3012		       00		      .byte.b	0
   1700  3012					      repend
   1701  3013		       00		      .byte.b	0
   1700  3013					      repend
   1701  3014		       00		      .byte.b	0
   1700  3014					      repend
   1701  3015		       00		      .byte.b	0
   1700  3015					      repend
   1701  3016		       00		      .byte.b	0
   1700  3016					      repend
   1701  3017		       00		      .byte.b	0
   1700  3017					      repend
   1701  3018		       00		      .byte.b	0
   1700  3018					      repend
   1701  3019		       00		      .byte.b	0
   1700  3019					      repend
   1701  301a		       00		      .byte.b	0
   1700  301a					      repend
   1701  301b		       00		      .byte.b	0
   1700  301b					      repend
   1701  301c		       00		      .byte.b	0
   1700  301c					      repend
   1701  301d		       00		      .byte.b	0
   1700  301d					      repend
   1701  301e		       00		      .byte.b	0
   1700  301e					      repend
   1701  301f		       00		      .byte.b	0
   1700  301f					      repend
   1701  3020		       00		      .byte.b	0
   1700  3020					      repend
   1701  3021		       00		      .byte.b	0
   1700  3021					      repend
   1701  3022		       00		      .byte.b	0
   1700  3022					      repend
   1701  3023		       00		      .byte.b	0
   1700  3023					      repend
   1701  3024		       00		      .byte.b	0
   1700  3024					      repend
   1701  3025		       00		      .byte.b	0
   1700  3025					      repend
   1701  3026		       00		      .byte.b	0
   1700  3026					      repend
   1701  3027		       00		      .byte.b	0
   1700  3027					      repend
   1701  3028		       00		      .byte.b	0
   1700  3028					      repend
   1701  3029		       00		      .byte.b	0
   1700  3029					      repend
   1701  302a		       00		      .byte.b	0
   1700  302a					      repend
   1701  302b		       00		      .byte.b	0
   1700  302b					      repend
   1701  302c		       00		      .byte.b	0
   1700  302c					      repend
   1701  302d		       00		      .byte.b	0
   1700  302d					      repend
   1701  302e		       00		      .byte.b	0
   1700  302e					      repend
   1701  302f		       00		      .byte.b	0
   1700  302f					      repend
   1701  3030		       00		      .byte.b	0
   1700  3030					      repend
   1701  3031		       00		      .byte.b	0
   1700  3031					      repend
   1701  3032		       00		      .byte.b	0
   1700  3032					      repend
   1701  3033		       00		      .byte.b	0
   1700  3033					      repend
   1701  3034		       00		      .byte.b	0
   1700  3034					      repend
   1701  3035		       00		      .byte.b	0
   1700  3035					      repend
   1701  3036		       00		      .byte.b	0
   1700  3036					      repend
   1701  3037		       00		      .byte.b	0
   1700  3037					      repend
   1701  3038		       00		      .byte.b	0
   1700  3038					      repend
   1701  3039		       00		      .byte.b	0
   1700  3039					      repend
   1701  303a		       00		      .byte.b	0
   1700  303a					      repend
   1701  303b		       00		      .byte.b	0
   1700  303b					      repend
   1701  303c		       00		      .byte.b	0
   1700  303c					      repend
   1701  303d		       00		      .byte.b	0
   1700  303d					      repend
   1701  303e		       00		      .byte.b	0
   1700  303e					      repend
   1701  303f		       00		      .byte.b	0
   1700  303f					      repend
   1701  3040		       00		      .byte.b	0
   1700  3040					      repend
   1701  3041		       00		      .byte.b	0
   1700  3041					      repend
   1701  3042		       00		      .byte.b	0
   1700  3042					      repend
   1701  3043		       00		      .byte.b	0
   1700  3043					      repend
   1701  3044		       00		      .byte.b	0
   1700  3044					      repend
   1701  3045		       00		      .byte.b	0
   1700  3045					      repend
   1701  3046		       00		      .byte.b	0
   1700  3046					      repend
   1701  3047		       00		      .byte.b	0
   1700  3047					      repend
   1701  3048		       00		      .byte.b	0
   1700  3048					      repend
   1701  3049		       00		      .byte.b	0
   1700  3049					      repend
   1701  304a		       00		      .byte.b	0
   1700  304a					      repend
   1701  304b		       00		      .byte.b	0
   1700  304b					      repend
   1701  304c		       00		      .byte.b	0
   1700  304c					      repend
   1701  304d		       00		      .byte.b	0
   1700  304d					      repend
   1701  304e		       00		      .byte.b	0
   1700  304e					      repend
   1701  304f		       00		      .byte.b	0
   1700  304f					      repend
   1701  3050		       00		      .byte.b	0
   1700  3050					      repend
   1701  3051		       00		      .byte.b	0
   1700  3051					      repend
   1701  3052		       00		      .byte.b	0
   1700  3052					      repend
   1701  3053		       00		      .byte.b	0
   1700  3053					      repend
   1701  3054		       00		      .byte.b	0
   1700  3054					      repend
   1701  3055		       00		      .byte.b	0
   1700  3055					      repend
   1701  3056		       00		      .byte.b	0
   1700  3056					      repend
   1701  3057		       00		      .byte.b	0
   1700  3057					      repend
   1701  3058		       00		      .byte.b	0
   1700  3058					      repend
   1701  3059		       00		      .byte.b	0
   1700  3059					      repend
   1701  305a		       00		      .byte.b	0
   1700  305a					      repend
   1701  305b		       00		      .byte.b	0
   1700  305b					      repend
   1701  305c		       00		      .byte.b	0
   1700  305c					      repend
   1701  305d		       00		      .byte.b	0
   1700  305d					      repend
   1701  305e		       00		      .byte.b	0
   1700  305e					      repend
   1701  305f		       00		      .byte.b	0
   1700  305f					      repend
   1701  3060		       00		      .byte.b	0
   1700  3060					      repend
   1701  3061		       00		      .byte.b	0
   1700  3061					      repend
   1701  3062		       00		      .byte.b	0
   1700  3062					      repend
   1701  3063		       00		      .byte.b	0
   1700  3063					      repend
   1701  3064		       00		      .byte.b	0
   1700  3064					      repend
   1701  3065		       00		      .byte.b	0
   1700  3065					      repend
   1701  3066		       00		      .byte.b	0
   1700  3066					      repend
   1701  3067		       00		      .byte.b	0
   1700  3067					      repend
   1701  3068		       00		      .byte.b	0
   1700  3068					      repend
   1701  3069		       00		      .byte.b	0
   1700  3069					      repend
   1701  306a		       00		      .byte.b	0
   1700  306a					      repend
   1701  306b		       00		      .byte.b	0
   1700  306b					      repend
   1701  306c		       00		      .byte.b	0
   1700  306c					      repend
   1701  306d		       00		      .byte.b	0
   1700  306d					      repend
   1701  306e		       00		      .byte.b	0
   1700  306e					      repend
   1701  306f		       00		      .byte.b	0
   1700  306f					      repend
   1701  3070		       00		      .byte.b	0
   1700  3070					      repend
   1701  3071		       00		      .byte.b	0
   1700  3071					      repend
   1701  3072		       00		      .byte.b	0
   1700  3072					      repend
   1701  3073		       00		      .byte.b	0
   1700  3073					      repend
   1701  3074		       00		      .byte.b	0
   1700  3074					      repend
   1701  3075		       00		      .byte.b	0
   1700  3075					      repend
   1701  3076		       00		      .byte.b	0
   1700  3076					      repend
   1701  3077		       00		      .byte.b	0
   1700  3077					      repend
   1701  3078		       00		      .byte.b	0
   1700  3078					      repend
   1701  3079		       00		      .byte.b	0
   1700  3079					      repend
   1701  307a		       00		      .byte.b	0
   1700  307a					      repend
   1701  307b		       00		      .byte.b	0
   1700  307b					      repend
   1701  307c		       00		      .byte.b	0
   1700  307c					      repend
   1701  307d		       00		      .byte.b	0
   1700  307d					      repend
   1701  307e		       00		      .byte.b	0
   1700  307e					      repend
   1701  307f		       00		      .byte.b	0
   1700  307f					      repend
   1701  3080		       00		      .byte.b	0
   1702  3081					      repend
   1703  3081				   .L033		;  temp1  =  temp1
   1704  3081
   1705  3081		       a5 cb		      LDA	temp1
   1706  3083		       85 cb		      STA	temp1
   1707  3085				   .
   1708  3085							; 
   1709  3085
   1710  3085				   .
   1711  3085							; 
   1712  3085
   1713  3085				   .L034		;  bank 4
   1714  3085
   1715  3085					      if	ECHO3
      3919 bytes of ROM space left in bank 3
   1716  3085					      echo	"    ",[(start_bank3 - *)]d , "bytes of ROM space left in bank 3")
   1717  3085					      endif
   1718  3085		       00 01	   ECHO3      =	1
   1719  3fd4					      ORG	$3FF4-bscode_length
   1720  3fd4					      RORG	$5FF4-bscode_length
   1721  3fd4		       a2 ff	   start_bank3 ldx	#$ff
   1722  3fd6					      ifconst	FASTFETCH	; using DPC+
   1723  3fd6		       8e 58 10 	      stx	FASTFETCH
   1724  3fd9					      endif
   1725  3fd9		       9a		      txs
   1726  3fda				  -	      if	bankswitch == 64
   1727  3fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1728  3fda					      else
   1729  3fda		       a9 18		      lda	#>(start-1)
   1730  3fdc					      endif
   1731  3fdc		       48		      pha
   1732  3fdd		       a9 e3		      lda	#<(start-1)
   1733  3fdf		       48		      pha
   1734  3fe0		       48		      pha
   1735  3fe1		       8a		      txa
   1736  3fe2		       48		      pha
   1737  3fe3		       ba		      tsx
   1738  3fe4					      if	bankswitch != 64
   1739  3fe4		       b5 04		      lda	4,x	; get high byte of return address
   1740  3fe6		       2a		      rol
   1741  3fe7		       2a		      rol
   1742  3fe8		       2a		      rol
   1743  3fe9		       2a		      rol
   1744  3fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1745  3fec		       aa		      tax
   1746  3fed		       e8		      inx
   1747  3fee				  -	      else
   1748  3fee				  -	      lda	4,x	; get high byte of return address
   1749  3fee				  -	      tay
   1750  3fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1751  3fee				  -	      sta	4,x
   1752  3fee				  -	      tya
   1753  3fee				  -	      lsr
   1754  3fee				  -	      lsr
   1755  3fee				  -	      lsr
   1756  3fee				  -	      lsr
   1757  3fee				  -	      tax
   1758  3fee				  -	      inx
   1759  3fee					      endif
   1760  3fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   1761  3ff1		       68		      pla
   1762  3ff2		       aa		      tax
   1763  3ff3		       68		      pla
   1764  3ff4		       60		      rts
   1765  3ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1766  3ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1767  3ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1768  3ff5					      endif
   1769  3ffc					      ORG	$3FFC
   1770  3ffc					      RORG	$5FFC
   1771  3ffc		       d4 5f		      .word.w	(start_bank3 & $ffff)
   1772  3ffe		       d4 5f		      .word.w	(start_bank3 & $ffff)
   1773  4000					      ORG	$4000
   1774  4000					      RORG	$7000
   1775  4000					      repeat	129
   1776  4000		       00		      .byte.b	0
   1775  4000					      repend
   1776  4001		       00		      .byte.b	0
   1775  4001					      repend
   1776  4002		       00		      .byte.b	0
   1775  4002					      repend
   1776  4003		       00		      .byte.b	0
   1775  4003					      repend
   1776  4004		       00		      .byte.b	0
   1775  4004					      repend
   1776  4005		       00		      .byte.b	0
   1775  4005					      repend
   1776  4006		       00		      .byte.b	0
   1775  4006					      repend
   1776  4007		       00		      .byte.b	0
   1775  4007					      repend
   1776  4008		       00		      .byte.b	0
   1775  4008					      repend
   1776  4009		       00		      .byte.b	0
   1775  4009					      repend
   1776  400a		       00		      .byte.b	0
   1775  400a					      repend
   1776  400b		       00		      .byte.b	0
   1775  400b					      repend
   1776  400c		       00		      .byte.b	0
   1775  400c					      repend
   1776  400d		       00		      .byte.b	0
   1775  400d					      repend
   1776  400e		       00		      .byte.b	0
   1775  400e					      repend
   1776  400f		       00		      .byte.b	0
   1775  400f					      repend
   1776  4010		       00		      .byte.b	0
   1775  4010					      repend
   1776  4011		       00		      .byte.b	0
   1775  4011					      repend
   1776  4012		       00		      .byte.b	0
   1775  4012					      repend
   1776  4013		       00		      .byte.b	0
   1775  4013					      repend
   1776  4014		       00		      .byte.b	0
   1775  4014					      repend
   1776  4015		       00		      .byte.b	0
   1775  4015					      repend
   1776  4016		       00		      .byte.b	0
   1775  4016					      repend
   1776  4017		       00		      .byte.b	0
   1775  4017					      repend
   1776  4018		       00		      .byte.b	0
   1775  4018					      repend
   1776  4019		       00		      .byte.b	0
   1775  4019					      repend
   1776  401a		       00		      .byte.b	0
   1775  401a					      repend
   1776  401b		       00		      .byte.b	0
   1775  401b					      repend
   1776  401c		       00		      .byte.b	0
   1775  401c					      repend
   1776  401d		       00		      .byte.b	0
   1775  401d					      repend
   1776  401e		       00		      .byte.b	0
   1775  401e					      repend
   1776  401f		       00		      .byte.b	0
   1775  401f					      repend
   1776  4020		       00		      .byte.b	0
   1775  4020					      repend
   1776  4021		       00		      .byte.b	0
   1775  4021					      repend
   1776  4022		       00		      .byte.b	0
   1775  4022					      repend
   1776  4023		       00		      .byte.b	0
   1775  4023					      repend
   1776  4024		       00		      .byte.b	0
   1775  4024					      repend
   1776  4025		       00		      .byte.b	0
   1775  4025					      repend
   1776  4026		       00		      .byte.b	0
   1775  4026					      repend
   1776  4027		       00		      .byte.b	0
   1775  4027					      repend
   1776  4028		       00		      .byte.b	0
   1775  4028					      repend
   1776  4029		       00		      .byte.b	0
   1775  4029					      repend
   1776  402a		       00		      .byte.b	0
   1775  402a					      repend
   1776  402b		       00		      .byte.b	0
   1775  402b					      repend
   1776  402c		       00		      .byte.b	0
   1775  402c					      repend
   1776  402d		       00		      .byte.b	0
   1775  402d					      repend
   1776  402e		       00		      .byte.b	0
   1775  402e					      repend
   1776  402f		       00		      .byte.b	0
   1775  402f					      repend
   1776  4030		       00		      .byte.b	0
   1775  4030					      repend
   1776  4031		       00		      .byte.b	0
   1775  4031					      repend
   1776  4032		       00		      .byte.b	0
   1775  4032					      repend
   1776  4033		       00		      .byte.b	0
   1775  4033					      repend
   1776  4034		       00		      .byte.b	0
   1775  4034					      repend
   1776  4035		       00		      .byte.b	0
   1775  4035					      repend
   1776  4036		       00		      .byte.b	0
   1775  4036					      repend
   1776  4037		       00		      .byte.b	0
   1775  4037					      repend
   1776  4038		       00		      .byte.b	0
   1775  4038					      repend
   1776  4039		       00		      .byte.b	0
   1775  4039					      repend
   1776  403a		       00		      .byte.b	0
   1775  403a					      repend
   1776  403b		       00		      .byte.b	0
   1775  403b					      repend
   1776  403c		       00		      .byte.b	0
   1775  403c					      repend
   1776  403d		       00		      .byte.b	0
   1775  403d					      repend
   1776  403e		       00		      .byte.b	0
   1775  403e					      repend
   1776  403f		       00		      .byte.b	0
   1775  403f					      repend
   1776  4040		       00		      .byte.b	0
   1775  4040					      repend
   1776  4041		       00		      .byte.b	0
   1775  4041					      repend
   1776  4042		       00		      .byte.b	0
   1775  4042					      repend
   1776  4043		       00		      .byte.b	0
   1775  4043					      repend
   1776  4044		       00		      .byte.b	0
   1775  4044					      repend
   1776  4045		       00		      .byte.b	0
   1775  4045					      repend
   1776  4046		       00		      .byte.b	0
   1775  4046					      repend
   1776  4047		       00		      .byte.b	0
   1775  4047					      repend
   1776  4048		       00		      .byte.b	0
   1775  4048					      repend
   1776  4049		       00		      .byte.b	0
   1775  4049					      repend
   1776  404a		       00		      .byte.b	0
   1775  404a					      repend
   1776  404b		       00		      .byte.b	0
   1775  404b					      repend
   1776  404c		       00		      .byte.b	0
   1775  404c					      repend
   1776  404d		       00		      .byte.b	0
   1775  404d					      repend
   1776  404e		       00		      .byte.b	0
   1775  404e					      repend
   1776  404f		       00		      .byte.b	0
   1775  404f					      repend
   1776  4050		       00		      .byte.b	0
   1775  4050					      repend
   1776  4051		       00		      .byte.b	0
   1775  4051					      repend
   1776  4052		       00		      .byte.b	0
   1775  4052					      repend
   1776  4053		       00		      .byte.b	0
   1775  4053					      repend
   1776  4054		       00		      .byte.b	0
   1775  4054					      repend
   1776  4055		       00		      .byte.b	0
   1775  4055					      repend
   1776  4056		       00		      .byte.b	0
   1775  4056					      repend
   1776  4057		       00		      .byte.b	0
   1775  4057					      repend
   1776  4058		       00		      .byte.b	0
   1775  4058					      repend
   1776  4059		       00		      .byte.b	0
   1775  4059					      repend
   1776  405a		       00		      .byte.b	0
   1775  405a					      repend
   1776  405b		       00		      .byte.b	0
   1775  405b					      repend
   1776  405c		       00		      .byte.b	0
   1775  405c					      repend
   1776  405d		       00		      .byte.b	0
   1775  405d					      repend
   1776  405e		       00		      .byte.b	0
   1775  405e					      repend
   1776  405f		       00		      .byte.b	0
   1775  405f					      repend
   1776  4060		       00		      .byte.b	0
   1775  4060					      repend
   1776  4061		       00		      .byte.b	0
   1775  4061					      repend
   1776  4062		       00		      .byte.b	0
   1775  4062					      repend
   1776  4063		       00		      .byte.b	0
   1775  4063					      repend
   1776  4064		       00		      .byte.b	0
   1775  4064					      repend
   1776  4065		       00		      .byte.b	0
   1775  4065					      repend
   1776  4066		       00		      .byte.b	0
   1775  4066					      repend
   1776  4067		       00		      .byte.b	0
   1775  4067					      repend
   1776  4068		       00		      .byte.b	0
   1775  4068					      repend
   1776  4069		       00		      .byte.b	0
   1775  4069					      repend
   1776  406a		       00		      .byte.b	0
   1775  406a					      repend
   1776  406b		       00		      .byte.b	0
   1775  406b					      repend
   1776  406c		       00		      .byte.b	0
   1775  406c					      repend
   1776  406d		       00		      .byte.b	0
   1775  406d					      repend
   1776  406e		       00		      .byte.b	0
   1775  406e					      repend
   1776  406f		       00		      .byte.b	0
   1775  406f					      repend
   1776  4070		       00		      .byte.b	0
   1775  4070					      repend
   1776  4071		       00		      .byte.b	0
   1775  4071					      repend
   1776  4072		       00		      .byte.b	0
   1775  4072					      repend
   1776  4073		       00		      .byte.b	0
   1775  4073					      repend
   1776  4074		       00		      .byte.b	0
   1775  4074					      repend
   1776  4075		       00		      .byte.b	0
   1775  4075					      repend
   1776  4076		       00		      .byte.b	0
   1775  4076					      repend
   1776  4077		       00		      .byte.b	0
   1775  4077					      repend
   1776  4078		       00		      .byte.b	0
   1775  4078					      repend
   1776  4079		       00		      .byte.b	0
   1775  4079					      repend
   1776  407a		       00		      .byte.b	0
   1775  407a					      repend
   1776  407b		       00		      .byte.b	0
   1775  407b					      repend
   1776  407c		       00		      .byte.b	0
   1775  407c					      repend
   1776  407d		       00		      .byte.b	0
   1775  407d					      repend
   1776  407e		       00		      .byte.b	0
   1775  407e					      repend
   1776  407f		       00		      .byte.b	0
   1775  407f					      repend
   1776  4080		       00		      .byte.b	0
   1777  4081					      repend
   1778  4081				   .L035		;  temp1  =  temp1
   1779  4081
   1780  4081		       a5 cb		      LDA	temp1
   1781  4083		       85 cb		      STA	temp1
   1782  4085				   .
   1783  4085							; 
   1784  4085
   1785  4085				   .
   1786  4085							; 
   1787  4085
   1788  4085				   .L036		;  bank 5
   1789  4085
   1790  4085					      if	ECHO4
      3919 bytes of ROM space left in bank 4
   1791  4085					      echo	"    ",[(start_bank4 - *)]d , "bytes of ROM space left in bank 4")
   1792  4085					      endif
   1793  4085		       00 01	   ECHO4      =	1
   1794  4fd4					      ORG	$4FF4-bscode_length
   1795  4fd4					      RORG	$7FF4-bscode_length
   1796  4fd4		       a2 ff	   start_bank4 ldx	#$ff
   1797  4fd6					      ifconst	FASTFETCH	; using DPC+
   1798  4fd6		       8e 58 10 	      stx	FASTFETCH
   1799  4fd9					      endif
   1800  4fd9		       9a		      txs
   1801  4fda				  -	      if	bankswitch == 64
   1802  4fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1803  4fda					      else
   1804  4fda		       a9 18		      lda	#>(start-1)
   1805  4fdc					      endif
   1806  4fdc		       48		      pha
   1807  4fdd		       a9 e3		      lda	#<(start-1)
   1808  4fdf		       48		      pha
   1809  4fe0		       48		      pha
   1810  4fe1		       8a		      txa
   1811  4fe2		       48		      pha
   1812  4fe3		       ba		      tsx
   1813  4fe4					      if	bankswitch != 64
   1814  4fe4		       b5 04		      lda	4,x	; get high byte of return address
   1815  4fe6		       2a		      rol
   1816  4fe7		       2a		      rol
   1817  4fe8		       2a		      rol
   1818  4fe9		       2a		      rol
   1819  4fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1820  4fec		       aa		      tax
   1821  4fed		       e8		      inx
   1822  4fee				  -	      else
   1823  4fee				  -	      lda	4,x	; get high byte of return address
   1824  4fee				  -	      tay
   1825  4fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1826  4fee				  -	      sta	4,x
   1827  4fee				  -	      tya
   1828  4fee				  -	      lsr
   1829  4fee				  -	      lsr
   1830  4fee				  -	      lsr
   1831  4fee				  -	      lsr
   1832  4fee				  -	      tax
   1833  4fee				  -	      inx
   1834  4fee					      endif
   1835  4fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   1836  4ff1		       68		      pla
   1837  4ff2		       aa		      tax
   1838  4ff3		       68		      pla
   1839  4ff4		       60		      rts
   1840  4ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1841  4ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1842  4ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1843  4ff5					      endif
   1844  4ffc					      ORG	$4FFC
   1845  4ffc					      RORG	$7FFC
   1846  4ffc		       d4 7f		      .word.w	(start_bank4 & $ffff)
   1847  4ffe		       d4 7f		      .word.w	(start_bank4 & $ffff)
   1848  5000					      ORG	$5000
   1849  5000					      RORG	$9000
   1850  5000					      repeat	129
   1851  5000		       00		      .byte.b	0
   1850  5000					      repend
   1851  5001		       00		      .byte.b	0
   1850  5001					      repend
   1851  5002		       00		      .byte.b	0
   1850  5002					      repend
   1851  5003		       00		      .byte.b	0
   1850  5003					      repend
   1851  5004		       00		      .byte.b	0
   1850  5004					      repend
   1851  5005		       00		      .byte.b	0
   1850  5005					      repend
   1851  5006		       00		      .byte.b	0
   1850  5006					      repend
   1851  5007		       00		      .byte.b	0
   1850  5007					      repend
   1851  5008		       00		      .byte.b	0
   1850  5008					      repend
   1851  5009		       00		      .byte.b	0
   1850  5009					      repend
   1851  500a		       00		      .byte.b	0
   1850  500a					      repend
   1851  500b		       00		      .byte.b	0
   1850  500b					      repend
   1851  500c		       00		      .byte.b	0
   1850  500c					      repend
   1851  500d		       00		      .byte.b	0
   1850  500d					      repend
   1851  500e		       00		      .byte.b	0
   1850  500e					      repend
   1851  500f		       00		      .byte.b	0
   1850  500f					      repend
   1851  5010		       00		      .byte.b	0
   1850  5010					      repend
   1851  5011		       00		      .byte.b	0
   1850  5011					      repend
   1851  5012		       00		      .byte.b	0
   1850  5012					      repend
   1851  5013		       00		      .byte.b	0
   1850  5013					      repend
   1851  5014		       00		      .byte.b	0
   1850  5014					      repend
   1851  5015		       00		      .byte.b	0
   1850  5015					      repend
   1851  5016		       00		      .byte.b	0
   1850  5016					      repend
   1851  5017		       00		      .byte.b	0
   1850  5017					      repend
   1851  5018		       00		      .byte.b	0
   1850  5018					      repend
   1851  5019		       00		      .byte.b	0
   1850  5019					      repend
   1851  501a		       00		      .byte.b	0
   1850  501a					      repend
   1851  501b		       00		      .byte.b	0
   1850  501b					      repend
   1851  501c		       00		      .byte.b	0
   1850  501c					      repend
   1851  501d		       00		      .byte.b	0
   1850  501d					      repend
   1851  501e		       00		      .byte.b	0
   1850  501e					      repend
   1851  501f		       00		      .byte.b	0
   1850  501f					      repend
   1851  5020		       00		      .byte.b	0
   1850  5020					      repend
   1851  5021		       00		      .byte.b	0
   1850  5021					      repend
   1851  5022		       00		      .byte.b	0
   1850  5022					      repend
   1851  5023		       00		      .byte.b	0
   1850  5023					      repend
   1851  5024		       00		      .byte.b	0
   1850  5024					      repend
   1851  5025		       00		      .byte.b	0
   1850  5025					      repend
   1851  5026		       00		      .byte.b	0
   1850  5026					      repend
   1851  5027		       00		      .byte.b	0
   1850  5027					      repend
   1851  5028		       00		      .byte.b	0
   1850  5028					      repend
   1851  5029		       00		      .byte.b	0
   1850  5029					      repend
   1851  502a		       00		      .byte.b	0
   1850  502a					      repend
   1851  502b		       00		      .byte.b	0
   1850  502b					      repend
   1851  502c		       00		      .byte.b	0
   1850  502c					      repend
   1851  502d		       00		      .byte.b	0
   1850  502d					      repend
   1851  502e		       00		      .byte.b	0
   1850  502e					      repend
   1851  502f		       00		      .byte.b	0
   1850  502f					      repend
   1851  5030		       00		      .byte.b	0
   1850  5030					      repend
   1851  5031		       00		      .byte.b	0
   1850  5031					      repend
   1851  5032		       00		      .byte.b	0
   1850  5032					      repend
   1851  5033		       00		      .byte.b	0
   1850  5033					      repend
   1851  5034		       00		      .byte.b	0
   1850  5034					      repend
   1851  5035		       00		      .byte.b	0
   1850  5035					      repend
   1851  5036		       00		      .byte.b	0
   1850  5036					      repend
   1851  5037		       00		      .byte.b	0
   1850  5037					      repend
   1851  5038		       00		      .byte.b	0
   1850  5038					      repend
   1851  5039		       00		      .byte.b	0
   1850  5039					      repend
   1851  503a		       00		      .byte.b	0
   1850  503a					      repend
   1851  503b		       00		      .byte.b	0
   1850  503b					      repend
   1851  503c		       00		      .byte.b	0
   1850  503c					      repend
   1851  503d		       00		      .byte.b	0
   1850  503d					      repend
   1851  503e		       00		      .byte.b	0
   1850  503e					      repend
   1851  503f		       00		      .byte.b	0
   1850  503f					      repend
   1851  5040		       00		      .byte.b	0
   1850  5040					      repend
   1851  5041		       00		      .byte.b	0
   1850  5041					      repend
   1851  5042		       00		      .byte.b	0
   1850  5042					      repend
   1851  5043		       00		      .byte.b	0
   1850  5043					      repend
   1851  5044		       00		      .byte.b	0
   1850  5044					      repend
   1851  5045		       00		      .byte.b	0
   1850  5045					      repend
   1851  5046		       00		      .byte.b	0
   1850  5046					      repend
   1851  5047		       00		      .byte.b	0
   1850  5047					      repend
   1851  5048		       00		      .byte.b	0
   1850  5048					      repend
   1851  5049		       00		      .byte.b	0
   1850  5049					      repend
   1851  504a		       00		      .byte.b	0
   1850  504a					      repend
   1851  504b		       00		      .byte.b	0
   1850  504b					      repend
   1851  504c		       00		      .byte.b	0
   1850  504c					      repend
   1851  504d		       00		      .byte.b	0
   1850  504d					      repend
   1851  504e		       00		      .byte.b	0
   1850  504e					      repend
   1851  504f		       00		      .byte.b	0
   1850  504f					      repend
   1851  5050		       00		      .byte.b	0
   1850  5050					      repend
   1851  5051		       00		      .byte.b	0
   1850  5051					      repend
   1851  5052		       00		      .byte.b	0
   1850  5052					      repend
   1851  5053		       00		      .byte.b	0
   1850  5053					      repend
   1851  5054		       00		      .byte.b	0
   1850  5054					      repend
   1851  5055		       00		      .byte.b	0
   1850  5055					      repend
   1851  5056		       00		      .byte.b	0
   1850  5056					      repend
   1851  5057		       00		      .byte.b	0
   1850  5057					      repend
   1851  5058		       00		      .byte.b	0
   1850  5058					      repend
   1851  5059		       00		      .byte.b	0
   1850  5059					      repend
   1851  505a		       00		      .byte.b	0
   1850  505a					      repend
   1851  505b		       00		      .byte.b	0
   1850  505b					      repend
   1851  505c		       00		      .byte.b	0
   1850  505c					      repend
   1851  505d		       00		      .byte.b	0
   1850  505d					      repend
   1851  505e		       00		      .byte.b	0
   1850  505e					      repend
   1851  505f		       00		      .byte.b	0
   1850  505f					      repend
   1851  5060		       00		      .byte.b	0
   1850  5060					      repend
   1851  5061		       00		      .byte.b	0
   1850  5061					      repend
   1851  5062		       00		      .byte.b	0
   1850  5062					      repend
   1851  5063		       00		      .byte.b	0
   1850  5063					      repend
   1851  5064		       00		      .byte.b	0
   1850  5064					      repend
   1851  5065		       00		      .byte.b	0
   1850  5065					      repend
   1851  5066		       00		      .byte.b	0
   1850  5066					      repend
   1851  5067		       00		      .byte.b	0
   1850  5067					      repend
   1851  5068		       00		      .byte.b	0
   1850  5068					      repend
   1851  5069		       00		      .byte.b	0
   1850  5069					      repend
   1851  506a		       00		      .byte.b	0
   1850  506a					      repend
   1851  506b		       00		      .byte.b	0
   1850  506b					      repend
   1851  506c		       00		      .byte.b	0
   1850  506c					      repend
   1851  506d		       00		      .byte.b	0
   1850  506d					      repend
   1851  506e		       00		      .byte.b	0
   1850  506e					      repend
   1851  506f		       00		      .byte.b	0
   1850  506f					      repend
   1851  5070		       00		      .byte.b	0
   1850  5070					      repend
   1851  5071		       00		      .byte.b	0
   1850  5071					      repend
   1851  5072		       00		      .byte.b	0
   1850  5072					      repend
   1851  5073		       00		      .byte.b	0
   1850  5073					      repend
   1851  5074		       00		      .byte.b	0
   1850  5074					      repend
   1851  5075		       00		      .byte.b	0
   1850  5075					      repend
   1851  5076		       00		      .byte.b	0
   1850  5076					      repend
   1851  5077		       00		      .byte.b	0
   1850  5077					      repend
   1851  5078		       00		      .byte.b	0
   1850  5078					      repend
   1851  5079		       00		      .byte.b	0
   1850  5079					      repend
   1851  507a		       00		      .byte.b	0
   1850  507a					      repend
   1851  507b		       00		      .byte.b	0
   1850  507b					      repend
   1851  507c		       00		      .byte.b	0
   1850  507c					      repend
   1851  507d		       00		      .byte.b	0
   1850  507d					      repend
   1851  507e		       00		      .byte.b	0
   1850  507e					      repend
   1851  507f		       00		      .byte.b	0
   1850  507f					      repend
   1851  5080		       00		      .byte.b	0
   1852  5081					      repend
   1853  5081				   .L037		;  temp1  =  temp1
   1854  5081
   1855  5081		       a5 cb		      LDA	temp1
   1856  5083		       85 cb		      STA	temp1
   1857  5085				   .
   1858  5085							; 
   1859  5085
   1860  5085				   .
   1861  5085							; 
   1862  5085
   1863  5085				   .L038		;  bank 6
   1864  5085
   1865  5085					      if	ECHO5
      3919 bytes of ROM space left in bank 5
   1866  5085					      echo	"    ",[(start_bank5 - *)]d , "bytes of ROM space left in bank 5")
   1867  5085					      endif
   1868  5085		       00 01	   ECHO5      =	1
   1869  5fd4					      ORG	$5FF4-bscode_length
   1870  5fd4					      RORG	$9FF4-bscode_length
   1871  5fd4		       a2 ff	   start_bank5 ldx	#$ff
   1872  5fd6					      ifconst	FASTFETCH	; using DPC+
   1873  5fd6		       8e 58 10 	      stx	FASTFETCH
   1874  5fd9					      endif
   1875  5fd9		       9a		      txs
   1876  5fda				  -	      if	bankswitch == 64
   1877  5fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1878  5fda					      else
   1879  5fda		       a9 18		      lda	#>(start-1)
   1880  5fdc					      endif
   1881  5fdc		       48		      pha
   1882  5fdd		       a9 e3		      lda	#<(start-1)
   1883  5fdf		       48		      pha
   1884  5fe0		       48		      pha
   1885  5fe1		       8a		      txa
   1886  5fe2		       48		      pha
   1887  5fe3		       ba		      tsx
   1888  5fe4					      if	bankswitch != 64
   1889  5fe4		       b5 04		      lda	4,x	; get high byte of return address
   1890  5fe6		       2a		      rol
   1891  5fe7		       2a		      rol
   1892  5fe8		       2a		      rol
   1893  5fe9		       2a		      rol
   1894  5fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1895  5fec		       aa		      tax
   1896  5fed		       e8		      inx
   1897  5fee				  -	      else
   1898  5fee				  -	      lda	4,x	; get high byte of return address
   1899  5fee				  -	      tay
   1900  5fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1901  5fee				  -	      sta	4,x
   1902  5fee				  -	      tya
   1903  5fee				  -	      lsr
   1904  5fee				  -	      lsr
   1905  5fee				  -	      lsr
   1906  5fee				  -	      lsr
   1907  5fee				  -	      tax
   1908  5fee				  -	      inx
   1909  5fee					      endif
   1910  5fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   1911  5ff1		       68		      pla
   1912  5ff2		       aa		      tax
   1913  5ff3		       68		      pla
   1914  5ff4		       60		      rts
   1915  5ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1916  5ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1917  5ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1918  5ff5					      endif
   1919  5ffc					      ORG	$5FFC
   1920  5ffc					      RORG	$9FFC
   1921  5ffc		       d4 9f		      .word.w	(start_bank5 & $ffff)
   1922  5ffe		       d4 9f		      .word.w	(start_bank5 & $ffff)
   1923  6000					      ORG	$6000
   1924  6000					      RORG	$B000
   1925  6000					      repeat	129
   1926  6000		       00		      .byte.b	0
   1925  6000					      repend
   1926  6001		       00		      .byte.b	0
   1925  6001					      repend
   1926  6002		       00		      .byte.b	0
   1925  6002					      repend
   1926  6003		       00		      .byte.b	0
   1925  6003					      repend
   1926  6004		       00		      .byte.b	0
   1925  6004					      repend
   1926  6005		       00		      .byte.b	0
   1925  6005					      repend
   1926  6006		       00		      .byte.b	0
   1925  6006					      repend
   1926  6007		       00		      .byte.b	0
   1925  6007					      repend
   1926  6008		       00		      .byte.b	0
   1925  6008					      repend
   1926  6009		       00		      .byte.b	0
   1925  6009					      repend
   1926  600a		       00		      .byte.b	0
   1925  600a					      repend
   1926  600b		       00		      .byte.b	0
   1925  600b					      repend
   1926  600c		       00		      .byte.b	0
   1925  600c					      repend
   1926  600d		       00		      .byte.b	0
   1925  600d					      repend
   1926  600e		       00		      .byte.b	0
   1925  600e					      repend
   1926  600f		       00		      .byte.b	0
   1925  600f					      repend
   1926  6010		       00		      .byte.b	0
   1925  6010					      repend
   1926  6011		       00		      .byte.b	0
   1925  6011					      repend
   1926  6012		       00		      .byte.b	0
   1925  6012					      repend
   1926  6013		       00		      .byte.b	0
   1925  6013					      repend
   1926  6014		       00		      .byte.b	0
   1925  6014					      repend
   1926  6015		       00		      .byte.b	0
   1925  6015					      repend
   1926  6016		       00		      .byte.b	0
   1925  6016					      repend
   1926  6017		       00		      .byte.b	0
   1925  6017					      repend
   1926  6018		       00		      .byte.b	0
   1925  6018					      repend
   1926  6019		       00		      .byte.b	0
   1925  6019					      repend
   1926  601a		       00		      .byte.b	0
   1925  601a					      repend
   1926  601b		       00		      .byte.b	0
   1925  601b					      repend
   1926  601c		       00		      .byte.b	0
   1925  601c					      repend
   1926  601d		       00		      .byte.b	0
   1925  601d					      repend
   1926  601e		       00		      .byte.b	0
   1925  601e					      repend
   1926  601f		       00		      .byte.b	0
   1925  601f					      repend
   1926  6020		       00		      .byte.b	0
   1925  6020					      repend
   1926  6021		       00		      .byte.b	0
   1925  6021					      repend
   1926  6022		       00		      .byte.b	0
   1925  6022					      repend
   1926  6023		       00		      .byte.b	0
   1925  6023					      repend
   1926  6024		       00		      .byte.b	0
   1925  6024					      repend
   1926  6025		       00		      .byte.b	0
   1925  6025					      repend
   1926  6026		       00		      .byte.b	0
   1925  6026					      repend
   1926  6027		       00		      .byte.b	0
   1925  6027					      repend
   1926  6028		       00		      .byte.b	0
   1925  6028					      repend
   1926  6029		       00		      .byte.b	0
   1925  6029					      repend
   1926  602a		       00		      .byte.b	0
   1925  602a					      repend
   1926  602b		       00		      .byte.b	0
   1925  602b					      repend
   1926  602c		       00		      .byte.b	0
   1925  602c					      repend
   1926  602d		       00		      .byte.b	0
   1925  602d					      repend
   1926  602e		       00		      .byte.b	0
   1925  602e					      repend
   1926  602f		       00		      .byte.b	0
   1925  602f					      repend
   1926  6030		       00		      .byte.b	0
   1925  6030					      repend
   1926  6031		       00		      .byte.b	0
   1925  6031					      repend
   1926  6032		       00		      .byte.b	0
   1925  6032					      repend
   1926  6033		       00		      .byte.b	0
   1925  6033					      repend
   1926  6034		       00		      .byte.b	0
   1925  6034					      repend
   1926  6035		       00		      .byte.b	0
   1925  6035					      repend
   1926  6036		       00		      .byte.b	0
   1925  6036					      repend
   1926  6037		       00		      .byte.b	0
   1925  6037					      repend
   1926  6038		       00		      .byte.b	0
   1925  6038					      repend
   1926  6039		       00		      .byte.b	0
   1925  6039					      repend
   1926  603a		       00		      .byte.b	0
   1925  603a					      repend
   1926  603b		       00		      .byte.b	0
   1925  603b					      repend
   1926  603c		       00		      .byte.b	0
   1925  603c					      repend
   1926  603d		       00		      .byte.b	0
   1925  603d					      repend
   1926  603e		       00		      .byte.b	0
   1925  603e					      repend
   1926  603f		       00		      .byte.b	0
   1925  603f					      repend
   1926  6040		       00		      .byte.b	0
   1925  6040					      repend
   1926  6041		       00		      .byte.b	0
   1925  6041					      repend
   1926  6042		       00		      .byte.b	0
   1925  6042					      repend
   1926  6043		       00		      .byte.b	0
   1925  6043					      repend
   1926  6044		       00		      .byte.b	0
   1925  6044					      repend
   1926  6045		       00		      .byte.b	0
   1925  6045					      repend
   1926  6046		       00		      .byte.b	0
   1925  6046					      repend
   1926  6047		       00		      .byte.b	0
   1925  6047					      repend
   1926  6048		       00		      .byte.b	0
   1925  6048					      repend
   1926  6049		       00		      .byte.b	0
   1925  6049					      repend
   1926  604a		       00		      .byte.b	0
   1925  604a					      repend
   1926  604b		       00		      .byte.b	0
   1925  604b					      repend
   1926  604c		       00		      .byte.b	0
   1925  604c					      repend
   1926  604d		       00		      .byte.b	0
   1925  604d					      repend
   1926  604e		       00		      .byte.b	0
   1925  604e					      repend
   1926  604f		       00		      .byte.b	0
   1925  604f					      repend
   1926  6050		       00		      .byte.b	0
   1925  6050					      repend
   1926  6051		       00		      .byte.b	0
   1925  6051					      repend
   1926  6052		       00		      .byte.b	0
   1925  6052					      repend
   1926  6053		       00		      .byte.b	0
   1925  6053					      repend
   1926  6054		       00		      .byte.b	0
   1925  6054					      repend
   1926  6055		       00		      .byte.b	0
   1925  6055					      repend
   1926  6056		       00		      .byte.b	0
   1925  6056					      repend
   1926  6057		       00		      .byte.b	0
   1925  6057					      repend
   1926  6058		       00		      .byte.b	0
   1925  6058					      repend
   1926  6059		       00		      .byte.b	0
   1925  6059					      repend
   1926  605a		       00		      .byte.b	0
   1925  605a					      repend
   1926  605b		       00		      .byte.b	0
   1925  605b					      repend
   1926  605c		       00		      .byte.b	0
   1925  605c					      repend
   1926  605d		       00		      .byte.b	0
   1925  605d					      repend
   1926  605e		       00		      .byte.b	0
   1925  605e					      repend
   1926  605f		       00		      .byte.b	0
   1925  605f					      repend
   1926  6060		       00		      .byte.b	0
   1925  6060					      repend
   1926  6061		       00		      .byte.b	0
   1925  6061					      repend
   1926  6062		       00		      .byte.b	0
   1925  6062					      repend
   1926  6063		       00		      .byte.b	0
   1925  6063					      repend
   1926  6064		       00		      .byte.b	0
   1925  6064					      repend
   1926  6065		       00		      .byte.b	0
   1925  6065					      repend
   1926  6066		       00		      .byte.b	0
   1925  6066					      repend
   1926  6067		       00		      .byte.b	0
   1925  6067					      repend
   1926  6068		       00		      .byte.b	0
   1925  6068					      repend
   1926  6069		       00		      .byte.b	0
   1925  6069					      repend
   1926  606a		       00		      .byte.b	0
   1925  606a					      repend
   1926  606b		       00		      .byte.b	0
   1925  606b					      repend
   1926  606c		       00		      .byte.b	0
   1925  606c					      repend
   1926  606d		       00		      .byte.b	0
   1925  606d					      repend
   1926  606e		       00		      .byte.b	0
   1925  606e					      repend
   1926  606f		       00		      .byte.b	0
   1925  606f					      repend
   1926  6070		       00		      .byte.b	0
   1925  6070					      repend
   1926  6071		       00		      .byte.b	0
   1925  6071					      repend
   1926  6072		       00		      .byte.b	0
   1925  6072					      repend
   1926  6073		       00		      .byte.b	0
   1925  6073					      repend
   1926  6074		       00		      .byte.b	0
   1925  6074					      repend
   1926  6075		       00		      .byte.b	0
   1925  6075					      repend
   1926  6076		       00		      .byte.b	0
   1925  6076					      repend
   1926  6077		       00		      .byte.b	0
   1925  6077					      repend
   1926  6078		       00		      .byte.b	0
   1925  6078					      repend
   1926  6079		       00		      .byte.b	0
   1925  6079					      repend
   1926  607a		       00		      .byte.b	0
   1925  607a					      repend
   1926  607b		       00		      .byte.b	0
   1925  607b					      repend
   1926  607c		       00		      .byte.b	0
   1925  607c					      repend
   1926  607d		       00		      .byte.b	0
   1925  607d					      repend
   1926  607e		       00		      .byte.b	0
   1925  607e					      repend
   1926  607f		       00		      .byte.b	0
   1925  607f					      repend
   1926  6080		       00		      .byte.b	0
   1927  6081					      repend
   1928  6081				   .L039		;  temp1  =  temp1
   1929  6081
   1930  6081		       a5 cb		      LDA	temp1
   1931  6083		       85 cb		      STA	temp1
   1932  6085					      if	ECHO6
      3919 bytes of ROM space left in bank 6
   1933  6085					      echo	"    ",[(start_bank6 - *)]d , "bytes of ROM space left in bank 6")
   1934  6085					      endif
   1935  6085		       00 01	   ECHO6      =	1
   1936  6fd4					      ORG	$6FF4-bscode_length
   1937  6fd4					      RORG	$BFF4-bscode_length
   1938  6fd4		       a2 ff	   start_bank6 ldx	#$ff
   1939  6fd6					      ifconst	FASTFETCH	; using DPC+
   1940  6fd6		       8e 58 10 	      stx	FASTFETCH
   1941  6fd9					      endif
   1942  6fd9		       9a		      txs
   1943  6fda				  -	      if	bankswitch == 64
   1944  6fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1945  6fda					      else
   1946  6fda		       a9 18		      lda	#>(start-1)
   1947  6fdc					      endif
   1948  6fdc		       48		      pha
   1949  6fdd		       a9 e3		      lda	#<(start-1)
   1950  6fdf		       48		      pha
   1951  6fe0		       48		      pha
   1952  6fe1		       8a		      txa
   1953  6fe2		       48		      pha
   1954  6fe3		       ba		      tsx
   1955  6fe4					      if	bankswitch != 64
   1956  6fe4		       b5 04		      lda	4,x	; get high byte of return address
   1957  6fe6		       2a		      rol
   1958  6fe7		       2a		      rol
   1959  6fe8		       2a		      rol
   1960  6fe9		       2a		      rol
   1961  6fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1962  6fec		       aa		      tax
   1963  6fed		       e8		      inx
   1964  6fee				  -	      else
   1965  6fee				  -	      lda	4,x	; get high byte of return address
   1966  6fee				  -	      tay
   1967  6fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1968  6fee				  -	      sta	4,x
   1969  6fee				  -	      tya
   1970  6fee				  -	      lsr
   1971  6fee				  -	      lsr
   1972  6fee				  -	      lsr
   1973  6fee				  -	      lsr
   1974  6fee				  -	      tax
   1975  6fee				  -	      inx
   1976  6fee					      endif
   1977  6fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   1978  6ff1		       68		      pla
   1979  6ff2		       aa		      tax
   1980  6ff3		       68		      pla
   1981  6ff4		       60		      rts
   1982  6ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1983  6ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1984  6ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1985  6ff5					      endif
   1986  6ffc					      ORG	$6FFC
   1987  6ffc					      RORG	$BFFC
   1988  6ffc		       d4 bf		      .word.w	(start_bank6 & $ffff)
   1989  6ffe		       d4 bf		      .word.w	(start_bank6 & $ffff)
   1990  7000					      ORG	$7000
   1991  7000					      RORG	$D000
   1992  7000					      repeat	129
   1993  7000		       00		      .byte.b	0
   1992  7000					      repend
   1993  7001		       00		      .byte.b	0
   1992  7001					      repend
   1993  7002		       00		      .byte.b	0
   1992  7002					      repend
   1993  7003		       00		      .byte.b	0
   1992  7003					      repend
   1993  7004		       00		      .byte.b	0
   1992  7004					      repend
   1993  7005		       00		      .byte.b	0
   1992  7005					      repend
   1993  7006		       00		      .byte.b	0
   1992  7006					      repend
   1993  7007		       00		      .byte.b	0
   1992  7007					      repend
   1993  7008		       00		      .byte.b	0
   1992  7008					      repend
   1993  7009		       00		      .byte.b	0
   1992  7009					      repend
   1993  700a		       00		      .byte.b	0
   1992  700a					      repend
   1993  700b		       00		      .byte.b	0
   1992  700b					      repend
   1993  700c		       00		      .byte.b	0
   1992  700c					      repend
   1993  700d		       00		      .byte.b	0
   1992  700d					      repend
   1993  700e		       00		      .byte.b	0
   1992  700e					      repend
   1993  700f		       00		      .byte.b	0
   1992  700f					      repend
   1993  7010		       00		      .byte.b	0
   1992  7010					      repend
   1993  7011		       00		      .byte.b	0
   1992  7011					      repend
   1993  7012		       00		      .byte.b	0
   1992  7012					      repend
   1993  7013		       00		      .byte.b	0
   1992  7013					      repend
   1993  7014		       00		      .byte.b	0
   1992  7014					      repend
   1993  7015		       00		      .byte.b	0
   1992  7015					      repend
   1993  7016		       00		      .byte.b	0
   1992  7016					      repend
   1993  7017		       00		      .byte.b	0
   1992  7017					      repend
   1993  7018		       00		      .byte.b	0
   1992  7018					      repend
   1993  7019		       00		      .byte.b	0
   1992  7019					      repend
   1993  701a		       00		      .byte.b	0
   1992  701a					      repend
   1993  701b		       00		      .byte.b	0
   1992  701b					      repend
   1993  701c		       00		      .byte.b	0
   1992  701c					      repend
   1993  701d		       00		      .byte.b	0
   1992  701d					      repend
   1993  701e		       00		      .byte.b	0
   1992  701e					      repend
   1993  701f		       00		      .byte.b	0
   1992  701f					      repend
   1993  7020		       00		      .byte.b	0
   1992  7020					      repend
   1993  7021		       00		      .byte.b	0
   1992  7021					      repend
   1993  7022		       00		      .byte.b	0
   1992  7022					      repend
   1993  7023		       00		      .byte.b	0
   1992  7023					      repend
   1993  7024		       00		      .byte.b	0
   1992  7024					      repend
   1993  7025		       00		      .byte.b	0
   1992  7025					      repend
   1993  7026		       00		      .byte.b	0
   1992  7026					      repend
   1993  7027		       00		      .byte.b	0
   1992  7027					      repend
   1993  7028		       00		      .byte.b	0
   1992  7028					      repend
   1993  7029		       00		      .byte.b	0
   1992  7029					      repend
   1993  702a		       00		      .byte.b	0
   1992  702a					      repend
   1993  702b		       00		      .byte.b	0
   1992  702b					      repend
   1993  702c		       00		      .byte.b	0
   1992  702c					      repend
   1993  702d		       00		      .byte.b	0
   1992  702d					      repend
   1993  702e		       00		      .byte.b	0
   1992  702e					      repend
   1993  702f		       00		      .byte.b	0
   1992  702f					      repend
   1993  7030		       00		      .byte.b	0
   1992  7030					      repend
   1993  7031		       00		      .byte.b	0
   1992  7031					      repend
   1993  7032		       00		      .byte.b	0
   1992  7032					      repend
   1993  7033		       00		      .byte.b	0
   1992  7033					      repend
   1993  7034		       00		      .byte.b	0
   1992  7034					      repend
   1993  7035		       00		      .byte.b	0
   1992  7035					      repend
   1993  7036		       00		      .byte.b	0
   1992  7036					      repend
   1993  7037		       00		      .byte.b	0
   1992  7037					      repend
   1993  7038		       00		      .byte.b	0
   1992  7038					      repend
   1993  7039		       00		      .byte.b	0
   1992  7039					      repend
   1993  703a		       00		      .byte.b	0
   1992  703a					      repend
   1993  703b		       00		      .byte.b	0
   1992  703b					      repend
   1993  703c		       00		      .byte.b	0
   1992  703c					      repend
   1993  703d		       00		      .byte.b	0
   1992  703d					      repend
   1993  703e		       00		      .byte.b	0
   1992  703e					      repend
   1993  703f		       00		      .byte.b	0
   1992  703f					      repend
   1993  7040		       00		      .byte.b	0
   1992  7040					      repend
   1993  7041		       00		      .byte.b	0
   1992  7041					      repend
   1993  7042		       00		      .byte.b	0
   1992  7042					      repend
   1993  7043		       00		      .byte.b	0
   1992  7043					      repend
   1993  7044		       00		      .byte.b	0
   1992  7044					      repend
   1993  7045		       00		      .byte.b	0
   1992  7045					      repend
   1993  7046		       00		      .byte.b	0
   1992  7046					      repend
   1993  7047		       00		      .byte.b	0
   1992  7047					      repend
   1993  7048		       00		      .byte.b	0
   1992  7048					      repend
   1993  7049		       00		      .byte.b	0
   1992  7049					      repend
   1993  704a		       00		      .byte.b	0
   1992  704a					      repend
   1993  704b		       00		      .byte.b	0
   1992  704b					      repend
   1993  704c		       00		      .byte.b	0
   1992  704c					      repend
   1993  704d		       00		      .byte.b	0
   1992  704d					      repend
   1993  704e		       00		      .byte.b	0
   1992  704e					      repend
   1993  704f		       00		      .byte.b	0
   1992  704f					      repend
   1993  7050		       00		      .byte.b	0
   1992  7050					      repend
   1993  7051		       00		      .byte.b	0
   1992  7051					      repend
   1993  7052		       00		      .byte.b	0
   1992  7052					      repend
   1993  7053		       00		      .byte.b	0
   1992  7053					      repend
   1993  7054		       00		      .byte.b	0
   1992  7054					      repend
   1993  7055		       00		      .byte.b	0
   1992  7055					      repend
   1993  7056		       00		      .byte.b	0
   1992  7056					      repend
   1993  7057		       00		      .byte.b	0
   1992  7057					      repend
   1993  7058		       00		      .byte.b	0
   1992  7058					      repend
   1993  7059		       00		      .byte.b	0
   1992  7059					      repend
   1993  705a		       00		      .byte.b	0
   1992  705a					      repend
   1993  705b		       00		      .byte.b	0
   1992  705b					      repend
   1993  705c		       00		      .byte.b	0
   1992  705c					      repend
   1993  705d		       00		      .byte.b	0
   1992  705d					      repend
   1993  705e		       00		      .byte.b	0
   1992  705e					      repend
   1993  705f		       00		      .byte.b	0
   1992  705f					      repend
   1993  7060		       00		      .byte.b	0
   1992  7060					      repend
   1993  7061		       00		      .byte.b	0
   1992  7061					      repend
   1993  7062		       00		      .byte.b	0
   1992  7062					      repend
   1993  7063		       00		      .byte.b	0
   1992  7063					      repend
   1993  7064		       00		      .byte.b	0
   1992  7064					      repend
   1993  7065		       00		      .byte.b	0
   1992  7065					      repend
   1993  7066		       00		      .byte.b	0
   1992  7066					      repend
   1993  7067		       00		      .byte.b	0
   1992  7067					      repend
   1993  7068		       00		      .byte.b	0
   1992  7068					      repend
   1993  7069		       00		      .byte.b	0
   1992  7069					      repend
   1993  706a		       00		      .byte.b	0
   1992  706a					      repend
   1993  706b		       00		      .byte.b	0
   1992  706b					      repend
   1993  706c		       00		      .byte.b	0
   1992  706c					      repend
   1993  706d		       00		      .byte.b	0
   1992  706d					      repend
   1993  706e		       00		      .byte.b	0
   1992  706e					      repend
   1993  706f		       00		      .byte.b	0
   1992  706f					      repend
   1993  7070		       00		      .byte.b	0
   1992  7070					      repend
   1993  7071		       00		      .byte.b	0
   1992  7071					      repend
   1993  7072		       00		      .byte.b	0
   1992  7072					      repend
   1993  7073		       00		      .byte.b	0
   1992  7073					      repend
   1993  7074		       00		      .byte.b	0
   1992  7074					      repend
   1993  7075		       00		      .byte.b	0
   1992  7075					      repend
   1993  7076		       00		      .byte.b	0
   1992  7076					      repend
   1993  7077		       00		      .byte.b	0
   1992  7077					      repend
   1993  7078		       00		      .byte.b	0
   1992  7078					      repend
   1993  7079		       00		      .byte.b	0
   1992  7079					      repend
   1993  707a		       00		      .byte.b	0
   1992  707a					      repend
   1993  707b		       00		      .byte.b	0
   1992  707b					      repend
   1993  707c		       00		      .byte.b	0
   1992  707c					      repend
   1993  707d		       00		      .byte.b	0
   1992  707d					      repend
   1993  707e		       00		      .byte.b	0
   1992  707e					      repend
   1993  707f		       00		      .byte.b	0
   1992  707f					      repend
   1993  7080		       00		      .byte.b	0
   1994  7081					      repend
   1995  7081							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1996  7081
   1997  7081							;----------------------------------------
   1998  7081							; Display Data
   1999  7081							;----------------------------------------
   2000  7081							; The Display Data bank is copied into RAM when DPC+ initializes the cartridge.
   2001  7081							; This allows us to manipulate the data during run-time, but have a known
   2002  7081							; starting state when the Atari is first turned on.
   2003  7081							;
   2004  7081							; Unlike normal Atari VCS/2600 sprite definitions, the sprite data in the
   2005  7081							; Display Data bank is stored right-side-up.
   2006  7081							;
   2007  7081							;----------------------------------------
   2008  7081
   2009  7081				   Zeros32
   2010  7081		       00 84	   SOUND_OFF  =	(* & $1fff)/32
   2011  7081				   DisplayDataDigitBlank
   2012  7081		       00		      .byte.b	0	;--
   2013  7082		       00		      .byte.b	0	;--
   2014  7083		       00		      .byte.b	0	;--
   2015  7084		       00		      .byte.b	0	;--
   2016  7085		       00		      .byte.b	0	;--
   2017  7086		       00		      .byte.b	0	;--
   2018  7087		       00		      .byte.b	0	;--
   2019  7088		       00		      .byte.b	0	;--
   2020  7089
   2021  7089							;	align 32
   2022  7089							;Zeros32:
   2023  7089							;SOUND_OFF = (* & $1fff)/32
   2024  7089							;	.byte 0,0,0,0,0,0,0,0
   2025  7089		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   2026  7091		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   2027  7099		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   2028  70a1
   2029  70a1		       00 85	   SINE_WAVE  =	(* & $1fff)/32
   2030  70a1		       03 03 03 04*	      .byte.b	3,3,3,4,4,5,5,5
   2031  70a9		       05 05 05 05*	      .byte.b	5,5,5,5,4,4,3,3
   2032  70b1		       03 02 02 01*	      .byte.b	3,2,2,1,1,0,0,0
   2033  70b9		       00 00 00 00*	      .byte.b	0,0,0,0,1,1,2,2
   2034  70c1
   2035  70e0		       00 00 00 00*	      align	32
   2036  70e0		       00 87	   TRIANGLE_WAVE =	(* & $1fff)/32
   2037  70e0		       00 00 01 01*	      .byte.b	0,0,1,1,1,2,2,2
   2038  70e8		       03 03 03 04*	      .byte.b	3,3,3,4,4,4,5,5
   2039  70f0		       05 05 04 04*	      .byte.b	5,5,4,4,4,3,3,3
   2040  70f8		       02 02 02 01*	      .byte.b	2,2,2,1,1,1,0,0
   2041  7100
   2042  7100					      align	32
   2043  7100		       00 88	   SAWTOOTH_WAVE =	(* & $1fff)/32
   2044  7100		       00 00 00 00*	      .byte.b	0,0,0,0,1,1,1,1
   2045  7108		       01 01 02 02*	      .byte.b	1,1,2,2,2,2,2,2
   2046  7110		       03 03 03 03*	      .byte.b	3,3,3,3,3,3,4,4
   2047  7118		       04 04 04 04*	      .byte.b	4,4,4,4,5,5,5,5
   2048  7120
   2049  7120					      align	32
   2050  7120		       00 89	   SQUARE_WAVE_VOL5 =	(* & $1fff)/32
   2051  7120		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   2052  7128		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   2053  7130		       05 05 05 05*	      .byte.b	5,5,5,5,5,5,5,5
   2054  7138		       05 05 05 05*	      .byte.b	5,5,5,5,5,5,5,5
   2055  7140
   2056  7140					      align	32
   2057  7140		       00 8a	   SQUARE_WAVE_VOL4 =	(* & $1fff)/32
   2058  7140		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   2059  7148		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   2060  7150		       04 04 04 04*	      .byte.b	4,4,4,4,4,4,4,4
   2061  7158		       04 04 04 04*	      .byte.b	4,4,4,4,4,4,4,4
   2062  7160
   2063  7160					      align	32
   2064  7160		       00 8b	   SQUARE_WAVE_VOL3 =	(* & $1fff)/32
   2065  7160		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   2066  7168		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   2067  7170		       03 03 03 03*	      .byte.b	3,3,3,3,3,3,3,3
   2068  7178		       03 03 03 03*	      .byte.b	3,3,3,3,3,3,3,3
   2069  7180
   2070  7180					      align	32
   2071  7180		       00 8c	   NOISE_WAVE =	(* & $1fff)/32
   2072  7180		       07 01 09 0a*	      .byte.b	7, 1, 9,10, 2, 8, 8,14
   2073  7188		       03 0d 08 05*	      .byte.b	3,13, 8, 5,12, 2, 3, 7
   2074  7190		       07 01 08 04*	      .byte.b	7, 1, 8, 4,15, 1,13, 5
   2075  7198		       08 05 0b 06*	      .byte.b	8, 5,11, 6, 8, 7, 9, 2
   2076  71a0
   2077  71a0							; low and high byte of address table (for ROMdata array in C)
   2078  71a0		       57		      .byte.b	<fetcher_address_table
   2079  71a1		       0d		      .byte.b	((>fetcher_address_table) & $0f) | (((>fetcher_address_table) / 2) & $70)
   2080  71a2		       00		      .byte.b	0
   2081  71a3		       00		      .byte.b	0
   2082  71a4				   FETCHER_BEGIN
   2083  71a4		       10		      .byte.b	16
   2084  71a5		       10		      .byte.b	16
   2085  71a6		       10		      .byte.b	16
   2086  71a7		       10		      .byte.b	16	; to zero-fill on boot
   2087  71a8							;bB.asm
   2088  71a8							; bB.asm file is split here
   2089  71a8				   playerL09_0
   2090  71a8		       40		      .byte.b	%01000000
   2091  71a9		       14		      .byte.b	%00010100
   2092  71aa		       b0		      .byte.b	%10110000
   2093  71ab		       02		      .byte.b	%00000010
   2094  71ac		       a0		      .byte.b	%10100000
   2095  71ad		       db		      .byte.b	%11011011
   2096  71ae		       7e		      .byte.b	%01111110
   2097  71af		       3c		      .byte.b	%00111100
   2098  71b0				   playercolorL010_0
   2099  71b0		       00		      .byte.b	$00
   2100  71b1		       00		      .byte.b	$00
   2101  71b2		       00		      .byte.b	$00
   2102  71b3		       00		      .byte.b	$00
   2103  71b4		       00		      .byte.b	$00
   2104  71b5		       00		      .byte.b	$00
   2105  71b6		       00		      .byte.b	$00
   2106  71b7		       00		      .byte.b	$00
   2107  71b8				   playfieldcolorL023
   2108  71b8		       0e		      .byte.b	$0E
   2109  71b9				   backgroundcolorL024
   2110  71b9		       00		      .byte.b	$00
   2111  71ba					      if	ECHOFIRST
      3610 bytes of ROM space left in graphics bank
   2112  71ba					      echo	"    ",[(DPC_graphics_end - *)]d , "bytes of ROM space left in graphics bank")
   2113  71ba					      endif
   2114  71ba		       00 01	   ECHOFIRST  =	1
   2115  71ba
   2116  71ba
   2117  71ba							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2118  71ba
   2119  7fd4					      ORG	$7FF4-bscode_length
   2120  7fd4					      RORG	$DFF4-bscode_length
   2121  7fd4				   DPC_graphics_end
   2122  7fd4
   2123  7fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2124  7fd4
   2125  7fd4							; every bank has this stuff at the same place
   2126  7fd4							; this code can switch to/from any bank at any entry point
   2127  7fd4							; and can preserve register values
   2128  7fd4							; note: lines not starting with a space are not placed in all banks
   2129  7fd4							;
   2130  7fd4							; line below tells the compiler how long this is - do not remove
   2131  7fd4							;size=32
   2132  7fd4
   2133  7fd4				   begin_bscode
   2134  7fd4		       a2 ff		      ldx	#$ff
   2135  7fd6					      ifconst	FASTFETCH	; using DPC+
   2136  7fd6		       8e 58 10 	      stx	FASTFETCH
   2137  7fd9					      endif
   2138  7fd9		       9a		      txs
   2139  7fda				  -	      if	bankswitch == 64
   2140  7fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   2141  7fda					      else
   2142  7fda		       a9 18		      lda	#>(start-1)
   2143  7fdc					      endif
   2144  7fdc		       48		      pha
   2145  7fdd		       a9 e3		      lda	#<(start-1)
   2146  7fdf		       48		      pha
   2147  7fe0
   2148  7fe0				   BS_return
   2149  7fe0		       48		      pha
   2150  7fe1		       8a		      txa
   2151  7fe2		       48		      pha
   2152  7fe3		       ba		      tsx
   2153  7fe4
   2154  7fe4					      if	bankswitch != 64
   2155  7fe4		       b5 04		      lda	4,x	; get high byte of return address
   2156  7fe6
   2157  7fe6		       2a		      rol
   2158  7fe7		       2a		      rol
   2159  7fe8		       2a		      rol
   2160  7fe9		       2a		      rol
   2161  7fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   2162  7fec		       aa		      tax
   2163  7fed		       e8		      inx
   2164  7fee				  -	      else
   2165  7fee				  -	      lda	4,x	; get high byte of return address
   2166  7fee				  -	      tay
   2167  7fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   2168  7fee				  -	      sta	4,x
   2169  7fee				  -	      tya
   2170  7fee				  -	      lsr
   2171  7fee				  -	      lsr
   2172  7fee				  -	      lsr
   2173  7fee				  -	      lsr
   2174  7fee				  -	      tax
   2175  7fee				  -	      inx
   2176  7fee					      endif
   2177  7fee
   2178  7fee				   BS_jsr
   2179  7fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   2180  7ff1		       68		      pla
   2181  7ff2		       aa		      tax
   2182  7ff3		       68		      pla
   2183  7ff4		       60		      rts
   2184  7ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   2185  7ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   2186  7ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   2187  7ff5					      endif
   2188  7ff5							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2189  7ff5
   2190  8000					      org	$8000
   2191  8000					      rorg	$1000
   2192  8000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2193  8000
   2194  8000							; 1K Frequency Table.
   2195  8000							; Fred Quimby, Darrell Spice Jr, Chris Walton 2010
   2196  8000							;
   2197  8000							; The 1K Frequency Table can contain up to 256 frequency values
   2198  8000							;
   2199  8000							; Table entries are defined as 2^32*freq/20000
   2200  8000							;
   2201  8000							; If User ARM code is being used, then the last 512 bytes of the frequency
   2202  8000							; table will no longer be available, reducing the number of frequencies you can
   2203  8000							; use to 128.
   2204  8000
   2205  8000							; piano key frequencies (s = sharp)
   2206  8000
   2207  8000				   .freq_table_start
   2208  8000
   2209  8000		       00 00 00 00	      DC.L	0
   2210  8000		       00 01	   A0	      =	(* & $3ff)/4
   2211  8004		       ac 1c 5a 00	      DC.L	5905580
   2212  8008
   2213  8008		       00 02	   A0s	      =	(* & $3ff)/4
   2214  8008		       68 78 5f 00	      DC.L	6256744
   2215  800c
   2216  800c		       00 03	   B0	      =	(* & $3ff)/4
   2217  800c		       b5 25 65 00	      DC.L	6628789
   2218  8010
   2219  8010		       00 04	   C1	      =	(* & $3ff)/4
   2220  8010		       6e 29 6b 00	      DC.L	7022958
   2221  8014
   2222  8014		       00 05	   C1s	      =	(* & $3ff)/4
   2223  8014		       b5 88 71 00	      DC.L	7440565
   2224  8018
   2225  8018		       00 06	   D1	      =	(* & $3ff)/4
   2226  8018		       fc 48 78 00	      DC.L	7883004
   2227  801c
   2228  801c		       00 07	   D1s	      =	(* & $3ff)/4
   2229  801c		       07 70 7f 00	      DC.L	8351751
   2230  8020
   2231  8020		       00 08	   E1	      =	(* & $3ff)/4
   2232  8020		       f4 03 87 00	      DC.L	8848372
   2233  8024
   2234  8024		       00 09	   F1	      =	(* & $3ff)/4
   2235  8024		       3c 0b 8f 00	      DC.L	9374524
   2236  8028
   2237  8028		       00 0a	   F1s	      =	(* & $3ff)/4
   2238  8028		       ba 8c 97 00	      DC.L	9931962
   2239  802c
   2240  802c		       00 0b	   G1	      =	(* & $3ff)/4
   2241  802c		       b3 8f a0 00	      DC.L	10522547
   2242  8030
   2243  8030		       00 0c	   G1s	      =	(* & $3ff)/4
   2244  8030		       db 1b aa 00	      DC.L	11148251
   2245  8034
   2246  8034		       00 0d	   A1	      =	(* & $3ff)/4
   2247  8034		       58 39 b4 00	      DC.L	11811160
   2248  8038
   2249  8038		       00 0e	   A1s	      =	(* & $3ff)/4
   2250  8038		       d0 f0 be 00	      DC.L	12513488
   2251  803c
   2252  803c		       00 0f	   B1	      =	(* & $3ff)/4
   2253  803c		       6b 4b ca 00	      DC.L	13257579
   2254  8040
   2255  8040		       00 10	   C2	      =	(* & $3ff)/4
   2256  8040		       dc 52 d6 00	      DC.L	14045916
   2257  8044
   2258  8044		       00 11	   C2s	      =	(* & $3ff)/4
   2259  8044		       69 11 e3 00	      DC.L	14881129
   2260  8048
   2261  8048		       00 12	   D2	      =	(* & $3ff)/4
   2262  8048		       f7 91 f0 00	      DC.L	15766007
   2263  804c
   2264  804c		       00 13	   D2s	      =	(* & $3ff)/4
   2265  804c		       0f e0 fe 00	      DC.L	16703503
   2266  8050
   2267  8050		       00 14	   E2	      =	(* & $3ff)/4
   2268  8050		       e9 07 0e 01	      DC.L	17696745
   2269  8054
   2270  8054		       00 15	   F2	      =	(* & $3ff)/4
   2271  8054		       78 16 1e 01	      DC.L	18749048
   2272  8058
   2273  8058		       00 16	   F2s	      =	(* & $3ff)/4
   2274  8058		       74 19 2f 01	      DC.L	19863924
   2275  805c
   2276  805c		       00 17	   G2	      =	(* & $3ff)/4
   2277  805c		       67 1f 41 01	      DC.L	21045095
   2278  8060
   2279  8060		       00 18	   G2s	      =	(* & $3ff)/4
   2280  8060		       b5 37 54 01	      DC.L	22296501
   2281  8064
   2282  8064		       00 19	   A2	      =	(* & $3ff)/4
   2283  8064		       b0 72 68 01	      DC.L	23622320
   2284  8068
   2285  8068		       00 1a	   A2s	      =	(* & $3ff)/4
   2286  8068		       a0 e1 7d 01	      DC.L	25026976
   2287  806c
   2288  806c		       00 1b	   B2	      =	(* & $3ff)/4
   2289  806c		       d6 96 94 01	      DC.L	26515158
   2290  8070
   2291  8070		       00 1c	   C3	      =	(* & $3ff)/4
   2292  8070		       b7 a5 ac 01	      DC.L	28091831
   2293  8074
   2294  8074		       00 1d	   C3s	      =	(* & $3ff)/4
   2295  8074		       d2 22 c6 01	      DC.L	29762258
   2296  8078
   2297  8078		       00 1e	   D3	      =	(* & $3ff)/4
   2298  8078		       ee 23 e1 01	      DC.L	31532014
   2299  807c
   2300  807c		       00 1f	   D3s	      =	(* & $3ff)/4
   2301  807c		       1d c0 fd 01	      DC.L	33407005
   2302  8080
   2303  8080		       00 20	   E3	      =	(* & $3ff)/4
   2304  8080		       d1 0f 1c 02	      DC.L	35393489
   2305  8084
   2306  8084		       00 21	   F3	      =	(* & $3ff)/4
   2307  8084		       f0 2c 3c 02	      DC.L	37498096
   2308  8088
   2309  8088		       00 22	   F3s	      =	(* & $3ff)/4
   2310  8088		       e9 32 5e 02	      DC.L	39727849
   2311  808c
   2312  808c		       00 23	   G3	      =	(* & $3ff)/4
   2313  808c		       cd 3e 82 02	      DC.L	42090189
   2314  8090
   2315  8090		       00 24	   G3s	      =	(* & $3ff)/4
   2316  8090		       6a 6f a8 02	      DC.L	44593002
   2317  8094
   2318  8094		       00 25	   A3	      =	(* & $3ff)/4
   2319  8094		       60 e5 d0 02	      DC.L	47244640
   2320  8098
   2321  8098		       00 26	   A3s	      =	(* & $3ff)/4
   2322  8098		       41 c3 fb 02	      DC.L	50053953
   2323  809c
   2324  809c		       00 27	   B3	      =	(* & $3ff)/4
   2325  809c		       ac 2d 29 03	      DC.L	53030316
   2326  80a0
   2327  80a0		       00 28	   C4	      =	(* & $3ff)/4
   2328  80a0		       6e 4b 59 03	      DC.L	56183662
   2329  80a4
   2330  80a4		       00 29	   C4s	      =	(* & $3ff)/4
   2331  80a4		       a5 45 8c 03	      DC.L	59524517
   2332  80a8
   2333  80a8		       00 2a	   D4	      =	(* & $3ff)/4
   2334  80a8		       dd 47 c2 03	      DC.L	63064029
   2335  80ac
   2336  80ac		       00 2b	   D4s	      =	(* & $3ff)/4
   2337  80ac		       3b 80 fb 03	      DC.L	66814011
   2338  80b0
   2339  80b0		       00 2c	   E4	      =	(* & $3ff)/4
   2340  80b0		       a3 1f 38 04	      DC.L	70786979
   2341  80b4
   2342  80b4		       00 2d	   F4	      =	(* & $3ff)/4
   2343  80b4		       e0 59 78 04	      DC.L	74996192
   2344  80b8
   2345  80b8		       00 2e	   F4s	      =	(* & $3ff)/4
   2346  80b8		       d1 65 bc 04	      DC.L	79455697
   2347  80bc
   2348  80bc		       00 2f	   G4	      =	(* & $3ff)/4
   2349  80bc		       9b 7d 04 05	      DC.L	84180379
   2350  80c0
   2351  80c0		       00 30	   G4s	      =	(* & $3ff)/4
   2352  80c0		       d5 de 50 05	      DC.L	89186005
   2353  80c4
   2354  80c4		       00 31	   A4	      =	(* & $3ff)/4
   2355  80c4		       c1 ca a1 05	      DC.L	94489281
   2356  80c8
   2357  80c8		       00 32	   A4s	      =	(* & $3ff)/4
   2358  80c8		       82 86 f7 05	      DC.L	100107906
   2359  80cc
   2360  80cc		       00 33	   B4	      =	(* & $3ff)/4
   2361  80cc		       57 5b 52 06	      DC.L	106060631
   2362  80d0
   2363  80d0		       00 34	   C5	      =	(* & $3ff)/4
   2364  80d0		       dd 96 b2 06	      DC.L	112367325
   2365  80d4
   2366  80d4		       00 35	   C5s	      =	(* & $3ff)/4
   2367  80d4		       4a 8b 18 07	      DC.L	119049034
   2368  80d8
   2369  80d8		       00 36	   D5	      =	(* & $3ff)/4
   2370  80d8		       b9 8f 84 07	      DC.L	126128057
   2371  80dc
   2372  80dc		       00 37	   D5s	      =	(* & $3ff)/4
   2373  80dc		       76 00 f7 07	      DC.L	133628022
   2374  80e0
   2375  80e0		       00 38	   E5	      =	(* & $3ff)/4
   2376  80e0		       46 3f 70 08	      DC.L	141573958
   2377  80e4
   2378  80e4		       00 39	   F5	      =	(* & $3ff)/4
   2379  80e4		       bf b3 f0 08	      DC.L	149992383
   2380  80e8
   2381  80e8		       00 3a	   F5s	      =	(* & $3ff)/4
   2382  80e8		       a3 cb 78 09	      DC.L	158911395
   2383  80ec
   2384  80ec		       00 3b	   G5	      =	(* & $3ff)/4
   2385  80ec		       36 fb 08 0a	      DC.L	168360758
   2386  80f0
   2387  80f0		       00 3c	   G5s	      =	(* & $3ff)/4
   2388  80f0		       a9 bd a1 0a	      DC.L	178372009
   2389  80f4
   2390  80f4		       00 3d	   A5	      =	(* & $3ff)/4
   2391  80f4		       81 95 43 0b	      DC.L	188978561
   2392  80f8
   2393  80f8		       00 3e	   A5s	      =	(* & $3ff)/4
   2394  80f8		       03 0d ef 0b	      DC.L	200215811
   2395  80fc
   2396  80fc		       00 3f	   B5	      =	(* & $3ff)/4
   2397  80fc		       af b6 a4 0c	      DC.L	212121263
   2398  8100
   2399  8100		       00 40	   C6	      =	(* & $3ff)/4
   2400  8100		       b9 2d 65 0d	      DC.L	224734649
   2401  8104
   2402  8104		       00 41	   C6s	      =	(* & $3ff)/4
   2403  8104		       93 16 31 0e	      DC.L	238098067
   2404  8108
   2405  8108		       00 42	   D6	      =	(* & $3ff)/4
   2406  8108		       73 1f 09 0f	      DC.L	252256115
   2407  810c
   2408  810c		       00 43	   D6s	      =	(* & $3ff)/4
   2409  810c		       ec 00 ee 0f	      DC.L	267256044
   2410  8110
   2411  8110		       00 44	   E6	      =	(* & $3ff)/4
   2412  8110		       8b 7e e0 10	      DC.L	283147915
   2413  8114
   2414  8114		       00 45	   F6	      =	(* & $3ff)/4
   2415  8114		       7f 67 e1 11	      DC.L	299984767
   2416  8118
   2417  8118		       00 46	   F6s	      =	(* & $3ff)/4
   2418  8118		       45 97 f1 12	      DC.L	317822789
   2419  811c
   2420  811c		       00 47	   G6	      =	(* & $3ff)/4
   2421  811c		       6c f6 11 14	      DC.L	336721516
   2422  8120
   2423  8120		       00 48	   G6s	      =	(* & $3ff)/4
   2424  8120		       53 7b 43 15	      DC.L	356744019
   2425  8124
   2426  8124		       00 49	   A6	      =	(* & $3ff)/4
   2427  8124		       02 2b 87 16	      DC.L	377957122
   2428  8128
   2429  8128		       00 4a	   A6s	      =	(* & $3ff)/4
   2430  8128		       06 1a de 17	      DC.L	400431622
   2431  812c
   2432  812c		       00 4b	   B6	      =	(* & $3ff)/4
   2433  812c		       5d 6d 49 19	      DC.L	424242525
   2434  8130
   2435  8130		       00 4c	   C7	      =	(* & $3ff)/4
   2436  8130		       73 5b ca 1a	      DC.L	449469299
   2437  8134
   2438  8134		       00 4d	   C7s	      =	(* & $3ff)/4
   2439  8134		       26 2d 62 1c	      DC.L	476196134
   2440  8138
   2441  8138		       00 4e	   D7	      =	(* & $3ff)/4
   2442  8138		       e6 3e 12 1e	      DC.L	504512230
   2443  813c
   2444  813c		       00 4f	   D7s	      =	(* & $3ff)/4
   2445  813c		       d8 01 dc 1f	      DC.L	534512088
   2446  8140
   2447  8140		       00 50	   E7	      =	(* & $3ff)/4
   2448  8140		       17 fd c0 21	      DC.L	566295831
   2449  8144
   2450  8144		       00 51	   F7	      =	(* & $3ff)/4
   2451  8144		       fd ce c2 23	      DC.L	599969533
   2452  8148
   2453  8148		       00 52	   F7s	      =	(* & $3ff)/4
   2454  8148		       8a 2e e3 25	      DC.L	635645578
   2455  814c
   2456  814c		       00 53	   G7	      =	(* & $3ff)/4
   2457  814c		       d7 ec 23 28	      DC.L	673443031
   2458  8150
   2459  8150		       00 54	   G7s	      =	(* & $3ff)/4
   2460  8150		       a6 f6 86 2a	      DC.L	713488038
   2461  8154
   2462  8154		       00 55	   A7	      =	(* & $3ff)/4
   2463  8154		       04 56 0e 2d	      DC.L	755914244
   2464  8158
   2465  8158		       00 56	   A7s	      =	(* & $3ff)/4
   2466  8158		       0c 34 bc 2f	      DC.L	800863244
   2467  815c
   2468  815c		       00 57	   B7	      =	(* & $3ff)/4
   2469  815c		       bb da 92 32	      DC.L	848485051
   2470  8160
   2471  8160		       00 58	   C8	      =	(* & $3ff)/4
   2472  8160		       e5 b6 94 35	      DC.L	898938597
   2473  8164
   2474  8164							;values for 89-255 may go here 
   2475  8164
   2476  8164					      if	(* <= $1400)
   2477  8164		       00 00 00 00*	      ds	($1400-*)	; pad out remaining space in frequency table
   2478  8400				  -	      else
   2479  8400				  -	      echo	"FATAL ERROR - Frequency table exceeds 1K"
   2480  8400				  -	      err
   2481  8400					      endif
